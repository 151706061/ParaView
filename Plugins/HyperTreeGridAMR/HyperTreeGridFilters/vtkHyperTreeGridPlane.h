/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkExtractCellsByType.h

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

/**
 * @class   vtkHyperTreeGridPlane
 * @brief   converts vtkDataSet to vtkHyperTreeGrid
 *
 * Given an input vtkDataSet and a subdivision strategy, given an input
 * scalar field, produces an output vtkHyperTreeGrid representing the input
 * vtkDataSet.
 *
 * The user should feed a pointer from a class deriving from vtkAbstractArrayMeasurement
 * to set ArrayMeasurement method for the subdividing strategy. This allows
 * to create at run-time the correct array measurement method all over the
 * vtkHyperTreeGrid.
 * By default, leaves in the vtkHyperTreeGrid are divided if the measured data
 * is between GetMin() and GetMax(). If GetInRange() == false, the leaves are
 * subdivided if the measured data is outside of GetMin() and GetMax()
 *
 * The user can also set a second pointer deriving from vtkAbstractArrayMeasurement
 * by setting ArrayMeasurementDisplay. This extra feature permits to have
 * subdividing strategies while keeping a handle on the "real" input data.
 * For example, one can set ArrayMeasurement to vtkStandardDeviationArrayMeasurement*
 * for subdividing, which will produce a vtkHyperTreeGrid whose nodes are bound
 * with the scalar field generated by the corresponding vtkStandardDeviationArrayMeasurement*.
 * In addition to that, the user can still visualize data "nearer" to the input data by
 * setting ArrayMeasurementDisplay to vtkMedianArrayMeasurement* for example, which would
 * produce an extra scalar field filled by the median of the subtree.
 *
 */

#ifndef vtkHyperTreeGridPlane_h
#define vtkHyperTreeGridPlane_h

#include <functional>
#include <vector>

#include "vtkAbstractArrayMeasurement.h"
#include "vtkAlgorithm.h"
#include "vtkCell.h"
#include "vtkFiltersGeneralModule.h" // For export macro
#include "vtkHyperTreeGridNonOrientedCursor.h"
#include "vtkTuple.h"

#include <limits>
#include <unordered_map>
#include <vector>

class VTKFILTERSGENERAL_EXPORT vtkHyperTreeGridPlane : public vtkAlgorithm
{
public:
  static vtkHyperTreeGridPlane* New();
  vtkTypeMacro(vtkHyperTreeGridPlane, vtkAlgorithm);
  void PrintSelf(ostream& os, vtkIndent indent) override;

  //@{
  /**
   * Set/Get the subdivision factor in the grid refinement scheme.
   */
  vtkSetClampMacro(BranchFactor, unsigned int, 2, 3);
  vtkGetMacro(BranchFactor, unsigned int);
  //@}

  //@{
  /**
   * Set/Get for ArrayMeasurement. Use it to feed a pointer of any subclass of
   * vtkAbstractArrayMeasurement,
   * which will be used to accumulate scalars from the input data set in order to produce the hyper
   * tree grid.
   */
  vtkGetMacro(ArrayMeasurement, vtkAbstractArrayMeasurement*);
  vtkSetMacro(ArrayMeasurement, vtkAbstractArrayMeasurement*);
  //@}

  //@{
  /**
   * Set/Get for ArrayMeasurement. Use it to feed a pointer of any subclass of
   * vtkAbstractArrayMeasurement,
   * which will be used to accumulate scalars from the input data. This measurement is not used for
   * subdivision,
   * it is only used for display purposes.
   * It should be used when subdividing using vtkStandardDeviationArrayMeasurement or
   * vtkEntropyArrayMeasurement
   * for example.
   * Default value is nullptr.
   */
  vtkGetMacro(ArrayMeasurementDisplay, vtkAbstractArrayMeasurement*);
  vtkSetMacro(ArrayMeasurementDisplay, vtkAbstractArrayMeasurement*);
  //@}

  //@{
  /**
   * Set/Get the maximum tree depth.
   */
  vtkSetMacro(MaxDepth, unsigned int);
  vtkGetMacro(MaxDepth, unsigned int);
  //@}

  //@{
  /**
   * Get/Set the maximum grid size of the hyper tree grid. All further resolution is creaded by
   * hyper trees.
   * The default is [4, 4, 4].
   */
  vtkSetVector3Macro(Dimensions, unsigned int);
  vtkGetVector3Macro(Dimensions, unsigned int);
  //@}

  //@{
  /**
   * Upper bound used to decide whether hyper tree grid should be refined or not
   * Default value is std::numeric_limits<double>infinity().
   */
  vtkGetMacro(Max, double);
  vtkSetMacro(Max, double);
  //@}

  //@{
  /**
   * Sets Max to infinity. Call this method to annihilate the upper bound.
   */
  void SetMaxToInfinity() { this->Max = std::numeric_limits<double>::infinity(); }
  //@}

  //@{
  /**
   * Lower bound used to decide whether hyper tree grid should be refined or not
   * Default value is -std::numeric_limits<double>::infinity().
   */
  vtkGetMacro(Min, double);
  vtkSetMacro(Min, double);
  //@}

  //@{
  /**
   * Sets Min to minus infinity. Call this method to annihilate the lower bound.
   */
  void SetMinToInfinity() { this->Min = -std::numeric_limits<double>::infinity(); }
  //@}

  //@{
  /**
   * Accessor for InRange. If set to true, the criterion for subdividing is true if the value is
   * within
   * the range. Otherwise, we subdivide for values outside of the range.
   */
  vtkBooleanMacro(InRange, bool);
  //@}

  void SetInputData(vtkDataObject*);
  void SetInputData(int, vtkDataObject*);

  virtual int ProcessRequest(
    vtkInformation*, vtkInformationVector**, vtkInformationVector*) override;

  int RequestDataObject(
    vtkInformation*, vtkInformationVector** inputVector, vtkInformationVector* outputVector);

  virtual int RequestUpdateExtent(vtkInformation*, vtkInformationVector**, vtkInformationVector*);

protected:
  vtkHyperTreeGridPlane();
  ~vtkHyperTreeGridPlane() override;

  // Override to specify support for any vtkDataSet input type.
  int FillInputPortInformation(int, vtkInformation*) override;
  // Override to specify output as vtkHyperTreeGrid.
  int FillOutputPortInformation(int, vtkInformation*) override;

  int RequestInformation(vtkInformation*, vtkInformationVector**, vtkInformationVector*);

  int RequestData(vtkInformation*, vtkInformationVector**, vtkInformationVector*);

  int ProcessTrees(vtkHyperTreeGrid*, vtkDataObject*);
  int GenerateTrees(vtkHyperTreeGrid*);

  unsigned int BranchFactor;
  unsigned int Dimensions[3];
  unsigned int MaxDepth;

  /**
   * Decides whether the criteria should be inside [this->Min, this->Max] or outside.
   */
  bool InRange;

  double Progress;

  vtkBitArray* Mask;

  /**
   * Only needed internally. Each element for each position in the multi resolution grid
   * stores the number of points in the subtree, as well as the concatenation of all the
   * accumulators
   * in the subtree. The data to accumulate needs to be associative.
   */
  struct GridElement
  {
    vtkAbstractArrayMeasurement* ArrayMeasurement;
    vtkAbstractArrayMeasurement* ArrayMeasurementDisplay;
    vtkIdType SizeOfSubtree;
  };

  /**
   * Only needed internally. This draws a multi resolution grid that should have this->MaxDepth
   * grids.
   * The resolution of each grid depends on the branch factor and the depth.
   * There should be, in a given direction, this->BranchFactor ^ depth elements.
   * Indexing is as follows:
   * elements indexed at (i,j,k) at depth maps to the element indexed at
   * (i/this->BranchFactor, j/this->BranchFactor, k/this->BranchFactor) at depth-1.
   * Element (i,j,k) bijectively maps to idx = this->CoordinatesToIndex(i,j,k,depth)
   * idx bijectively maps to element (i,j,k) = this->IndexToCoordinates(idx,depth)
   * this->CoordinatesToIndex and this->IndexToCoordinates are involutive.
   */
  typedef std::vector<std::unordered_map<vtkIdType, GridElement> > MultiResolutionGridType;

  /**
   * Method that divides recursively leafs of the output hyper tree grid depending of the
   * subdivision criterion
   * The cursor should correspond with the multiResolutionGrid and (i,j,k) should match the position
   * of the cursor in the hyper tree grid
   */
  void SubdivideLeaves(vtkHyperTreeGridNonOrientedCursor* cursor, vtkIdType treeId, std::size_t i,
    std::size_t j, std::size_t k, MultiResolutionGridType& multiResolutionGrid);

  /**
   * Method for clearing the grid of multi resolution grids
   */
  void DeleteGridOfMultiResolutionGrids();

  /**
   * Given an input dataSet and its corresponding scalar field data, fills a grid of multi
   * resolution grids
   * matching the subdivision scheme of the output hyper tree grid.
   */
  void CreateGridOfMultiResolutionGrids(vtkDataSet* dataSet, vtkDataArray* data);

  /**
   * Not sure if we keep those
   */
  bool DepthBelowHasNullCell(vtkIdType level, vtkIdType i, vtkIdType j, vtkIdType k) const;
  bool DepthBelowHasNoCell(vtkIdType level, vtkIdType i, vtkIdType j, vtkIdType k) const;
  void FillGaps(vtkCell* cell, double bounds[6], vtkIdType i, vtkIdType j, vtkIdType k,
    vtkIdType imax, vtkIdType jmax, vtkIdType kmax, std::size_t depth,
    vtkIdType currentResolutionPerTree);

  /**
   * Helper for easy access to the cells dimensions of the hyper tree grid
   */
  unsigned int CellDims[3];

  /**
   * Output scalar/vector field
   */
  vtkDoubleArray *ScalarField, ScalarFieldDisplay;

  /**
   * Helper to the maximum resolution in one direction in a hyper tree
   */
  vtkIdType MaxResolutionPerTree;
  /**
   * Helper to the resolution at a certain depth in one direction of a hyper tree
   */
  std::vector<vtkIdType> ResolutionPerTree;

  /**
   * Dummy pointer forcreating at run-time the proper type of ArrayMeasurement or
   * ArrayMeasurementDisplay
   */
  vtkAbstractArrayMeasurement* ArrayMeasurement;
  vtkAbstractArrayMeasurement* ArrayMeasurementDisplay;

  /**
   * Converts indexing at given resolution to a tuple (i,j,k) to navigate in a MultiResolutionGrid.
   */
  vtkTuple<vtkIdType, 3> IndexToCoordinates(vtkIdType idx, std::size_t depth) const
  {
    vtkTuple<vtkIdType, 3> coord;
    coord[0] = idx % (this->ResolutionPerTree[depth]);
    coord[1] = (idx / this->ResolutionPerTree[depth]) % this->ResolutionPerTree[depth];
    coord[2] = idx / (this->ResolutionPerTree[depth] * this->ResolutionPerTree[depth]);
    return coord;
  }

  /**
   * Converts (i,j,k) to the corresponding index at a certain depth to navigate in a
   * MultiResolutionGrid.
   */
  vtkIdType CoordinatesToIndex(std::size_t i, std::size_t j, std::size_t k, std::size_t depth) const
  {
    return i + j * this->ResolutionPerTree[depth] +
      k * this->ResolutionPerTree[depth] * this->ResolutionPerTree[depth];
  }

  /**
   * 3D grid of multi-resolution grids.
   * this->GridOfMultiResolutionGrids[i][j][k][depth][idx] is a GridElement.
   */
  std::vector<std::vector<std::vector<MultiResolutionGridType> > > GridOfMultiResolutionGrids;

private:
  vtkHyperTreeGridPlane(const vtkHyperTreeGridPlane&) = delete;
  void operator=(const vtkHyperTreeGridPlane&) = delete;
};

#endif
