/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkHyperTreeGridAnalysisDrivenRefinement.h

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

/**
 * @class   vtkHyperTreeGridAnalysisDrivenRefinement
 * @brief   converts vtkDataSet to vtkHyperTreeGrid
 *
 * Given an input vtkDataSet and a subdivision strategy, given an input
 * scalar field, produces an output vtkHyperTreeGrid representing the input
 * vtkDataSet.
 *
 * The user should feed a pointer from a class deriving from vtkAbstractArrayMeasurement
 * to set ArrayMeasurement method for the subdividing strategy. This allows
 * to create at run-time the correct array measurement method all over the
 * vtkHyperTreeGrid.
 * By default, leaves in the vtkHyperTreeGrid are divided if the measured data
 * is between GetMin() and GetMax(). If GetInRange() == false, the leaves are
 * subdivided if the measured data is outside of GetMin() and GetMax()
 *
 * The user can also set a second pointer deriving from vtkAbstractArrayMeasurement
 * by setting ArrayMeasurementDisplay. This extra feature permits to have
 * subdividing strategies while keeping a handle on the "real" input data.
 * For example, one can set ArrayMeasurement to vtkStandardDeviationArrayMeasurement*
 * for subdividing, which will produce a vtkHyperTreeGrid whose nodes are bound
 * with the scalar field generated by the corresponding vtkStandardDeviationArrayMeasurement*.
 * In addition to that, the user can still visualize data "nearer" to the input data by
 * setting ArrayMeasurementDisplay to vtkMedianArrayMeasurement* for example, which would
 * produce an extra scalar field filled by the median of the subtree.
 *
 */

#ifndef vtkHyperTreeGridAnalysisDrivenRefinement_h
#define vtkHyperTreeGridAnalysisDrivenRefinement_h

#include "vtkAlgorithm.h"
#include "vtkFiltersGeneralModule.h" // For export macro
#include "vtkTuple.h"

#include <unordered_map>
#include <vector>

class vtkAbstractArrayMeasurement;
class vtkAbstractAccumulator;
class vtkBitArray;
class vtkCell;
class vtkDataArray;
class vtkDataSet;
class vtkDoubleArray;
class vtkHyperTreeGrid;
class vtkHyperTreeGridNonOrientedCursor;
class vtkInformation;
class vtkInformationVector;
class vtkLongArray;

class VTKFILTERSGENERAL_EXPORT vtkHyperTreeGridAnalysisDrivenRefinement : public vtkAlgorithm
{
public:
  static vtkHyperTreeGridAnalysisDrivenRefinement* New();
  vtkTypeMacro(vtkHyperTreeGridAnalysisDrivenRefinement, vtkAlgorithm);
  void PrintSelf(ostream& os, vtkIndent indent) override;

  //@{
  /**
   * Set/Get the subdivision factor in the grid refinement scheme.
   */
  vtkSetClampMacro(BranchFactor, unsigned int, 2, 3);
  vtkGetMacro(BranchFactor, unsigned int);
  //@}

  //@{
  /**
   * Set/Get for ArrayMeasurement. Use it to feed a pointer of any subclass of
   * vtkAbstractArrayMeasurement,
   * which will be used to accumulate scalars from the input data set in order to produce the hyper
   * tree grid.
   */
  vtkGetMacro(ArrayMeasurement, vtkAbstractArrayMeasurement*);
  vtkSetMacro(ArrayMeasurement, vtkAbstractArrayMeasurement*);
  //@}

  //@{
  /**
   * Set/Get for ArrayMeasurement. Use it to feed a pointer of any subclass of
   * vtkAbstractArrayMeasurement,
   * which will be used to accumulate scalars from the input data. This measurement is not used for
   * subdivision,
   * it is only used for display purposes.
   * It should be used when subdividing using vtkStandardDeviationArrayMeasurement or
   * vtkEntropyArrayMeasurement
   * for example.
   * Default value is nullptr.
   */
  vtkGetMacro(ArrayMeasurementDisplay, vtkAbstractArrayMeasurement*);
  vtkSetMacro(ArrayMeasurementDisplay, vtkAbstractArrayMeasurement*);
  //@}

  //@{
  /**
   * Set/Get the maximum tree depth.
   */
  vtkSetMacro(MaxDepth, unsigned int);
  vtkGetMacro(MaxDepth, unsigned int);
  //@}

  //@{
  /**
   * Get/Set the maximum grid size of the hyper tree grid. All further resolution is creaded by
   * hyper trees.
   * The default is [4, 4, 4].
   */
  vtkSetVector3Macro(Dimensions, unsigned int);
  vtkGetVector3Macro(Dimensions, unsigned int);
  //@}

  //@{
  /**
   * Upper bound used to decide whether hyper tree grid should be refined or not
   * Default value is std::numeric_limits<double>infinity().
   */
  vtkGetMacro(Max, double);
  vtkSetMacro(Max, double);
  //@}

  //@{
  /**
   * Sets Max to infinity. Call this method to annihilate the upper bound.
   */
  void SetMaxToInfinity();
  //@}

  //@{
  /**
   * Lower bound used to decide whether hyper tree grid should be refined or not
   * Default value is -std::numeric_limits<double>::infinity().
   */
  vtkGetMacro(Min, double);
  vtkSetMacro(Min, double);
  //@}

  //@{
  /**
   * Sets Min to minus infinity. Call this method to annihilate the lower bound.
   */
  void SetMinToInfinity();
  //@}

  //@{
  /**
   * Accessor for InRange. If set to true, the criterion for subdividing is true if the value is
   * within
   * the range. Otherwise, we subdivide for values outside of the range.
   */
  vtkGetMacro(InRange, bool);
  vtkSetMacro(InRange, bool);
  //@}

  //@{
  /**
   * Accessor for MinimumNumberOfPointsInSubtree, which sets a minimum number of points per leaf.
   * Note that the minimum number of points can also be set by the vtkAbstractArrayMeasurement*
   * if it requires a higher minimum number of points that this->MinimumNumberOfPointsInSubtree.
   * Default value is 1.
   */
  vtkGetMacro(MinimumNumberOfPointsInSubtree, vtkIdType);
  vtkSetMacro(MinimumNumberOfPointsInSubtree, vtkIdType);
  //@}

  virtual int ProcessRequest(
    vtkInformation*, vtkInformationVector**, vtkInformationVector*) override;

  int RequestDataObject(
    vtkInformation*, vtkInformationVector** inputVector, vtkInformationVector* outputVector);

  virtual int RequestUpdateExtent(vtkInformation*, vtkInformationVector**, vtkInformationVector*);

protected:
  vtkHyperTreeGridAnalysisDrivenRefinement();
  ~vtkHyperTreeGridAnalysisDrivenRefinement() override;

  int FillInputPortInformation(int, vtkInformation*) override;

  int FillOutputPortInformation(int, vtkInformation*) override;

  int RequestInformation(vtkInformation*, vtkInformationVector**, vtkInformationVector*);

  int RequestData(vtkInformation*, vtkInformationVector**, vtkInformationVector*);

  int ProcessTrees(vtkHyperTreeGrid*, vtkDataObject*);
  int GenerateTrees(vtkHyperTreeGrid*);

  unsigned int BranchFactor;
  unsigned int Dimensions[3];
  unsigned int MaxDepth;

  /**
   * Range values used to decide whether to subdivide a leaf or not
   */
  double Min, Max;

  /**
   * Decides whether the criteria should be inside [this->Min, this->Max] or outside.
   */
  bool InRange;

  double Progress;

  vtkBitArray* Mask;

  /**
   * Only needed internally. Each element for each position in the multi resolution grid
   * stores the number of points in the subtree, as well as the concatenation of all the
   * accumulators
   * in the subtree. The data to accumulate needs to be associative.
   */
  struct GridElement
  {
    /**
     * Accumulators used for measuring quantities on subtrees
     */
    std::vector<vtkAbstractAccumulator*> Accumulators;

    vtkIdType NumberOfLeavesInSubtree;
    vtkIdType NumberOfPointsInSubtree;

    /**
     * Flag to tell whether it is legit to subdivide the corresponding leaf in the hyper tree.
     * A leaf cannot be subdivided if there is not enough data in the induced leaves.
     */
    bool CanSubdivide;
  };

  /**
   * Only needed internally. This draws a multi resolution grid that should have this->MaxDepth
   * grids.
   * The resolution of each grid depends on the branch factor and the depth.
   * There should be, in a given direction, this->BranchFactor ^ depth elements.
   * Indexing is as follows:
   * elements indexed at (i,j,k) at depth maps to the element indexed at
   * (i/this->BranchFactor, j/this->BranchFactor, k/this->BranchFactor) at depth-1.
   * Element (i,j,k) bijectively maps to idx = this->CoordinatesToIndex(i,j,k,depth), and
   * idx bijectively maps to element (i,j,k) = this->IndexToCoordinates(idx,depth).
   * this->CoordinatesToIndex is the inverse function of this->IndexToCoordinates.
   */
  typedef std::vector<std::unordered_map<vtkIdType, GridElement> > MultiResolutionGridType;

  /**
   * Method that divides recursively leafs of the output hyper tree grid depending of the
   * subdivision criterion
   * The cursor should correspond with the multiResolutionGrid and (i,j,k) should match the position
   * of the cursor in the hyper tree grid.
   */
  void SubdivideLeaves(vtkHyperTreeGridNonOrientedCursor* cursor, vtkIdType treeId, std::size_t i,
    std::size_t j, std::size_t k, MultiResolutionGridType& multiResolutionGrid);

  /**
   * Method for clearing the grid of multi resolution grids
   */
  void DeleteGridOfMultiResolutionGrids();

  /**
   * Given an input dataSet and its corresponding scalar field data, fills a grid of multi
   * resolution grids
   * matching the subdivision scheme of the output hyper tree grid.
   */
  void CreateGridOfMultiResolutionGrids(vtkDataSet* dataSet, vtkDataArray* data);

  /**
   * Helper for easy access to the cells dimensions of the hyper tree grid.
   */
  unsigned int CellDims[3];

  /**
   * Output scalar/vector field
   */
  vtkDoubleArray *ScalarField, *DisplayScalarField;
  vtkLongArray *NumberOfLeavesInSubtreeField, *NumberOfPointsInSubtreeField;

  /**
   * Minimum number of points in a leaf for it to be subdivided.
   */
  vtkIdType MinimumNumberOfPointsInSubtree;

  /**
   * Helper to the maximum resolution in one direction in a hyper tree.
   */
  vtkIdType MaxResolutionPerTree;

  /**
   * Helper to the resolution at a certain depth in one direction of a hyper tree.
   */
  std::vector<vtkIdType> ResolutionPerTree;

  /**
   * Dummy pointer for creating at run-time the proper type of ArrayMeasurement or
   * ArrayMeasurementDisplay.
   */
  vtkAbstractArrayMeasurement* ArrayMeasurement;
  vtkAbstractArrayMeasurement* ArrayMeasurementDisplay;

  /**
   * Converts indexing at given resolution to a tuple (i,j,k) to navigate in a MultiResolutionGrid.
   */
  vtkTuple<vtkIdType, 3> IndexToCoordinates(vtkIdType idx, std::size_t depth) const;

  /**
   * Converts (i,j,k) to the corresponding index at a certain depth to navigate in a
   * MultiResolutionGrid.
   */
  vtkIdType CoordinatesToIndex(
    std::size_t i, std::size_t j, std::size_t k, std::size_t depth) const;

  /**
   * 3D grid of multi-resolution grids.
   * this->GridOfMultiResolutionGrids[i][j][k][depth][idx] is a GridElement.
   */
  std::vector<std::vector<std::vector<MultiResolutionGridType> > > GridOfMultiResolutionGrids;

  /**
   * Maps from the vector of vtkAbstractAccumulator* of GridElement to their position
   * in the accumulator needed by either this->ArrayMeasurementDisplay.
   */
  std::vector<std::size_t> ArrayMeasurementDisplayAccumulatorMap;

  /**
   * Accumulators needed to compute the measures. They are used as dummy pointers
   * to create the correct instances when creating the grid of multi-resolution grids.
   */
  std::vector<vtkAbstractAccumulator*> Accumulators;

  /**
   * Buffer to store the pointers of the correct accumulator when measuring.
   * We only use them if this->ArrayMeasurementDisplay != nullptr
   */
  std::vector<vtkAbstractAccumulator *> ArrayMeasurementAccumulators,
    ArrayMeasurementDisplayAccumulators;

private:
  vtkHyperTreeGridAnalysisDrivenRefinement(
    const vtkHyperTreeGridAnalysisDrivenRefinement&) = delete;
  void operator=(const vtkHyperTreeGridAnalysisDrivenRefinement&) = delete;
};

#endif
