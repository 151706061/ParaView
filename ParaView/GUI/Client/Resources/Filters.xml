<ModuleInterfaces>
  <Module name="SurfaceVectors"
          button_image="PVSurfaceVectorsButton"
          button_visibility="0"
          button_help="Constrain a vector field to lie on a surface.  Glyphs must be used to display the vector field."
          root_name="SurfaceV"
          menu_name="Surface Vectors"
          module_type="Filter"
          long_help="This filter constrains vectors to lie on a surface."
          short_help="This filter constrains vectors o lie on a surface.">
    <Filter class="vtkSurfaceVectors">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu property="SelectInputVectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               help="Select the input vectors to process."/>
    <SelectionList property="ConstraintMode"
                   label="Constraint Mode"
                   trace_name="ConstraintMode"
                   help="Constrain vector relative to surface.">
      <Item name="Parallel" value="0"/>
      <Item name="Perpendicular" value="1"/>
      <Item name="PerpendicularScale" value="2"/>
    </SelectionList>
    <Documentation>
The surface vectors filter is used for 2D data sets.  It constrains vectors to lie in a surface by removing components of the vectors normal to the local surface.
    </Documentation>
  </Module>
  <Module name="IntegrateAttributes"
          class="vtkPVPick"
          root_name="Integrate"
          replace_input="0"
          menu_name="Integrate Attributes"
          module_type="Filter"
          long_help="This filter integrates cell and point attributes.  Use selects whether the integration is over 1D lines, 2D surfaces or 3D volumes.  Cells not of the selected dimension are ignored."
          short_help="Integrates over lines, surfaces or vectors.">
    <Filter class="vtkIntegrateAttributes">
      <Input name="Input"
             class="vtkDataSet">
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
Integrates point and cell data over lines and surfaces.  It also computes length of lines, area of surface or volume.
    </Documentation>
  </Module>
  
  <Module name="IntegrateFlowThroughSurface"
          class="vtkPVPick"
          button_image="PVIntegrateFlowButton"
          button_help="Integrate a vector field through a surface. 3D cells are ignored."
          button_visibility="0"
          root_name="SurfaceFlow"
          menu_name="Surface Flow"
          module_type="Filter"
          long_help="This filter integrates flow through a surface."
          short_help="This filter integrates flow through a surface.">
    <Filter class="vtkIntegrateFlowThroughSurface">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu property="SelectInputVectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               help="Select the input vectors to process."/>
    <Documentation>
The flow integration fitler  integrates the dot product of a point flow vector field and surface normal.  It computes the net flow across the 2D surface..
    </Documentation>
  </Module>  

<!-- #ifdef PARAVIEW_BUILD_DEVELOPMENT -->
  <Module name="StructuredGridOutlineFilter"
          menu_name="Outline (curvilinear)"
          root_name="GOutline"
            module_type="Filter">
    <Filter class="vtkStructuredGridOutlineFilter">
      <Input name="Input"
             class="vtkStructuredGrid"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
  </Module>
<!-- #endif -->










  <Module name="Balance"
          root_name="Balance" module_type="Filter"
          multiprocess_support="multiple_processes"
          long_help="Balance data among available processes."
          short_help="Load balance filter.">
    <Filter class="vtkBalancedRedistributePolyData">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Balance the number of cells on all processes."
               input_name="Input"/>
    <Documentation>
The Balance filter is available when ParaView is run in parallel. It does load-balancing so that all processes have the same number of cells. It operates on polygonal data sets and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="Delaunay2D"
          root_name="Delaunay2D" module_type="Filter"
          long_help="Create 2D Delaunay triangulation of input points. 
It expects a vtkPointSet as input and produces vtkPolyData as output. 
The points are expected to be in a mostly planar distribution."
          short_help="Create 2D Delaunay triangulation of input points.">
    <Filter class="vtkDelaunay2D">
      <Input name="Input"
             class="vtkPointSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               input_name="Input"/>
    <SelectionList property="ProjectionPlaneMode"
                   trace_name="ProjectionPlaneMode"
                   label="ProjectionPlaneMode"
                   help="Select ProjectionPlaneMode">
      <Item name="Only XY coordinates"
            value="0"/>
      <!--
      <Item name="VTK_SET_TRANSFORM_PLANE"
            value="1"/>
      -->
      <Item name="Project on best-fitting plane"
            value="2"/>
    </SelectionList>
    <ThumbWheel label="Alpha"
                property="Alpha"
                trace_name="Alpha"
                type="float"
                resolution="0.01"
                minimum_value="0"
                help="Specify alpha (or distance) value to control output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output." />

    <ThumbWheel label="Tolerance"
                trace_name="Tolerance"
                property="Tolerance"
                resolution="0.001"
                minimum_value="0"
                help="Specify a tolerance to control discarding of closely spaced points.
This tolerance is specified as a fraction of the diagonal length of the bounding
box of the points." />

    <ThumbWheel label="Offset"
                trace_name="Offset"
                property="Offset"
                resolution="0.1"
                minimum_value="1"
                help="Specify a multiplier to control the size of the initial, bounding Delaunay triangulation." />

    <LabeledToggle label="Bounding Triangulation"
                   trace_name="BoundingTriangulation"
                   property="BoundingTriangulation"
                   help="If checked, bounding triangulation points (and associated triangles) are included in the
output. (These are introduced as an initial triangulation to begin the triangulation process.
This feature is nice for debugging output.)" />
    <Documentation>
Delaunay2D is a filter that constructs a 2D Delaunay triangulation from 
a list of input points. These points may be represented by any dataset 
of type vtkPointSet and subclasses. The output of the filter is a 
polygonal dataset containing a triangle mesh.

The 2D Delaunay triangulation is defined as the triangulation that 
satisfies the Delaunay criterion for n-dimensional simplexes (in this 
case n=2 and the simplexes are triangles). This criterion states that a 
circumsphere of each simplex in a triangulation contains only the n+1 
defining points of the simplex. (See "The Visualization Toolkit" text 
for more information.) In two dimensions, this translates into an 
optimal triangulation. That is, the maximum interior angle of any 
triangle is less than or equal to that of any possible triangulation.

Delaunay triangulations are used to build topological structures from 
unorganized (or unstructured) points. The input to this filter is a list 
of points specified in 3D, even though the triangulation is 2D. Thus the 
triangulation is constructed in the x-y plane, and the z coordinate is 
ignored (although carried through to the output). You can use the option
ProjectionPlaneMode in order to compute the best-fitting plane to the
set of points, project the points and that plane and then perform the
triangulation using their projected positions and then use it as the 
plane in which the triangulation is performed.

The Delaunay triangulation can be numerically sensitive in some cases. 
To prevent problems, try to avoid injecting points that will result in 
triangles with bad aspect ratios (1000:1 or greater). In practice this 
means inserting points that are "widely dispersed", and enables smooth 
transition of triangle sizes throughout the mesh. (You may even want to 
add extra points to create a better point distribution.) If numerical 
problems are present, you will see a warning message to this effect at 
the end of the triangulation process.

Warning:
     Points arranged on a regular lattice (termed degenerate cases) can 
be triangulated in more than one way (at least according to the Delaunay 
criterion). The choice of triangulation (as implemented by this 
algorithm) depends on the order of the input points. The first three 
points will form a triangle; other degenerate points will not break this 
triangle.

     Points that are coincident (or nearly so) may be discarded by the 
algorithm. This is because the Delaunay triangulation requires unique 
input points. The output of the Delaunay triangulation is supposedly a 
convex hull. In certain cases this implementation may not generate the 
convex hull.
    </Documentation>
  </Module>
  <Module name="AllToN"
          root_name="AllToN" module_type="Filter" menu_name="All to N"
          multiprocess_support="multiple_processes"
          long_help="Redistribute data to a subset of available processes."
          short_help="Repartition data filter.">
    <Filter class="vtkAllToNRedistributePolyData">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Redistribute polydata to a subset of processes."
               input_name="Input"/>
    <VectorEntry label="Number of Processes" trace_name="NumberOfProcesses"
                 property="NumberOfProcesses"
                 type="int"/>
    <Documentation>
The All to N filter is available when ParaView is run in parallel. It redistributes the data so that it is located on the number of processes specified in the Number of Processes entry box. It also does load-balancing of the data among these processes. This filter operates on polygonal data and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="AppendAttributes"
          menu_name="Append Attributes"
          root_name="AppendAttr"
          module_type="Filter"
          long_help="Copies geometry from first input.  Puts all of the arrays into the output."
          short_help="Puts all input arrays into the single output.">
    <Filter class="vtkMergeArrays">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <GroupInputsWidget trace_name="inputs" property="Input"
                       help="Choose inputs to append."/>
    <Documentation>
The Append Attributes filter takes multiple input data sets with the same geometry and merges their point and cell attributes to produce a single output containing all the point and cell attributes of the inputs. Any inputs without the same number of points and cells as the first input are ignored. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
    </Documentation>
  </Module>
  <Module name="AppendPolyData"
          menu_name="Append Geometry"
          root_name="AppendGeo"
          module_type="Filter"
          long_help="Takes an input of multiple poly data parts and output has only one part."
          short_help="Append multiple parts into one.">
    <Filter class="vtkAppendPolyData">
      <Input name="Input"
             class="vtkPolyData" quantity="Multiple">
      </Input>
    </Filter>
    <GroupInputsWidget trace_name="inputs" property="Input"
                       help="Choose inputs to append."/>
    <Documentation>
The Append Geometry filter operates on multiple polygonal data sets. The data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets. It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output.
    </Documentation>
  </Module>
  <Module name="Append"
          menu_name="Append Datasets"
          root_name="Append"
          module_type="Filter"
          long_help="Takes an input of multiple datasets and output has only one unstructured grid."
          short_help="Append multiple datasets into one.">
    <Filter class="vtkAppendFilter">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <GroupInputsWidget trace_name="inputs" property="Input"
                       help="Choose inputs to append."/>
    <Documentation>
The Append Datasets filter operates on multiple data sets of any type (polygonal, structured, etc.). It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
    </Documentation>
  </Module>
  <Module name="CellCenters"
          menu_name="Cell Centers"
          root_name="Centers"
          module_type="Filter"
          long_help="Create a point (no geometry) at the center of each input cell."
          short_help="Convert cells to vertices.">
    <Filter class="vtkCellCenters">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Generate vertices"
                   trace_name="VertexCells"
                   property="VertexCells"
                   help="Generate vertex as geometry of just points."/>
    <Documentation>
The Cell Centers filter places a point at the center of each cell in the input data set. The center computed is the parametric center of the cell, not necessarily the geometric or bounding box center. The cell attributes of the input will be associated with these newly created points of the output. The Input menu allows the user to select the data set to which this filter will be applied. If the Generate vertices option is checked, then vertex cells will also be created for each point in the output. This is useful because vertex cells are rendered, but points are not. The points themselves could be used for placing glyphs (using the Glyph filter). The Cell Centers filter takes any type of data set as input and produces a polygonal data set as output.
    </Documentation>
  </Module>
  <Module name="CellDataToPointData"
          root_name="CellToPoint"
          menu_name="Cell Data to Point Data"
          module_type="Filter"
          long_help="Create point attributes by averaging cell attributes."
          short_help="Convert cell data to point data.">
    <Filter class="vtkPCellDataToPointData">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Cell"/>
        <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Pass cell data"
                   trace_name="PassCellData"
                   property="PassCellData"
                   help=" Control whether the input cell data is to be passed to the output. If on, then the input cell data is passed through to the output; otherwise, only generated point data is placed into the output."/>
    <Documentation>
The Cell Data to Point Data filter averages the values of the cell attributes of the cells surrounding a point to compute point attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass cell data option is checked, then the input cell attributes will also be copied to the cell attributes of the output; otherwise the output will only have point attributes. The Cell Data to Point Data filter operates on any type of data set, and the output data set is of the same type as the input.
    </Documentation>
  </Module>
  <Module name="CleanPolyData"
          menu_name="Clean" root_name="CleanPD"
          module_type="Filter"
          long_help="Merge coincident points if they do not meet a feature edge critera."
          short_help="Merge coincident points.">
    <Filter class="vtkCleanPolyData">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Piece invariant"
                   trace_name="PieceInvariant"
                   property="PieceInvariant"
                   help="Turn this on to remove seams when running in parallel."/>
    <Scale label="Tolerance"
           trace_name="Tolerance"
           property="Tolerance"
           help="The tolerance in terms of fraction of bounding box length."
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0" display_value="0"/>
    <ThumbWheel label="Absolute tolerance"
                property="AbsoluteTolerance"
                trace_name="AbsoluteTolerance"
                resolution="0.01"
                minimum_value="0"
                help="The tolerance in absolute terms."/>
    <LabeledToggle label="Tolerance is absolute"
                   trace_name="ToleranceIsAbsolute"
                   property="ToleranceIsAbsolute"
                   help="Turn this on to use the absolute tolerance."/>
    <LabeledToggle label="Convert lines to points"
                   trace_name="ConvertLinesToPoints"
                   property="ConvertLinesToPoints"
                   help="Turn on/off conversion of degenerate lines to points."/>
    <LabeledToggle label="Convert polys to lines"
                   trace_name="ConvertPolysToLines"
                   property="ConvertPolysToLines"
                   help="Turn on/off conversion of degenerate polys to lines."/>
    <LabeledToggle label="Convert strips to polys"
                   trace_name="ConvertStripsToPolys"
                   property="ConvertStripsToPolys"
                   help="Turn on/off conversion of degenerate strips to polys."/>
    <LabeledToggle label="Point merging"
                   trace_name="PointMerging"
                   property="PointMerging"
                   help="Turn this On to control wheter points merging is performed."/>
    <Documentation>
The Clean filter takes polygonal data as input and generates polygonal data as output. This filter can merge duplicate points, remove unused points, and transform degenerate cells into their appropriate forms (e.g., a triangle is converted into a line if two of its points are merged). The Input menu allows the user to select the data set to which this filter will be applied. If the Point merging option is on, then points will be merged if they are within the specified Tolerance or Absolute tolerance, depending on whether the Tolerance is absolute box is checked. (Tolerance is specified as a fraction of the length of the diagonal of the bounding box of the data set; Absolute tolerance is specified in the spatial units of the input data set.)
The transforming of degenerate cells into their appropriate forms is controlled by three check boxes on the user interface: Convert lines to points, Convert polys to lines, and Convert strips to polys. If any of these is unchecked, then degenerate cells of that type will not be converted to another type of cell.
If the Piece invariant option is checked, the whole data set will be processed at once so that cleaning this data set always produces the same results. If the box is unchecked, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory, but the results are not guaranteed to be the same as they would be if the Piece invariant option was on.
    </Documentation>
  </Module>
  <Module name="CleanUnstructuredGrid"
          menu_name="Clean to Grid"
          root_name="CleanUGrid"
          module_type="Filter"
          long_help="This filter merges points and converts the data set to unstructured grid."
          short_help="Merge points.">
    <Filter class="vtkCleanUnstructuredGrid">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Clean to Grid filter merges points that are within a tolerance of 1/100,000 of the length of the diagonal of the bounding box of the data set. It also converts the data set to an unstructured grid. You may wish to do this if you want to apply a filter to your data set that is available for unstructured grids but not for the initial type of your data set (e.g., applying warp vector to volumetric data). The Input menu allows the user to select the data set to which this filter will be applied. The Clean to Grid filter operates on any type of data set.
    </Documentation>
  </Module>
  <Module name="PVConnectivityFilter"
          menu_name="Connectivity"
          root_name="Connect"
          module_type="Filter"
          long_help="Mark connected components with integer point attribute array."
          short_help="Find connected components.">
    <Filter class="vtkPVConnectivityFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Connectivity filter assigns a region id to connected components of the input data set. (The region id is assigned as a point scalar value.) The Input menu allows the user to select the data set to which this filter will be applied. This filter takes any data set type as input and produces unstructured grid output.
    </Documentation>
  </Module>
  <Module name="ImageClip"
          menu_name="Crop" root_name="ImageClip"
          module_type="Filter"
          replace_input="0"
          long_help="Efficiently extract an area/volume of interest from a 2-d image or 3-d volume."
          short_help="Extract a volume of interest.">
    <Filter class="vtkImageClip">
      <Input name="Input"
             class="vtkImageData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ExtentEntry label="Extent to crop"
                 trace_name="OutputWholeExtent"
                 property="OutputWholeExtent"
                 input_menu="im"
                 help="Set the min/max extents in each dimension of the output"/>
    <Documentation>
The Crop filter extracts an area/volume of interest from a 2D image or a 3D volume by allowing the user to specify the minimum and maximum extents of each dimension of the data. The Input menu allows the user to select the data set to which this filter will be applied. Both the input and output of this filter are uniform rectilinear data.
    </Documentation>
  </Module>
  <Module name="Curvatures"
          menu_name="Curvature"
          root_name="Curvatures"
          module_type="Filter"
          long_help="This filter will compute the gaussian or mean curvature of the mesh at each point."
          short_help="Compute the curvature at each point.">
    <Filter class="vtkCurvatures">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Invert mean curvature"
                   trace_name="InvertMeanCurvature"
                   property="InvertMeanCurvature"
                   help="Turn this on to invert the mean curvature calculation for meshes with inward pointing normals."/>
    <SelectionList property="CurvatureType"
                   label="Curvature type"
                   trace_name="CurvatureType"
                   help="Select the curvature type.">
      <Item name="Gaussian" value="0"/>
      <Item name="Mean" value="1"/>
    </SelectionList>
    <Documentation>
The Curvature filter computes the curvature at each point in a polygonal data set. This filter supports both Gaussian and mean curvatures; the type can be selected from the Curvature type menu button. The Input menu allows the user to select the data set to which this filter will be applied. If the Invert mean curvature option is checked, the mean curvature calculation will be inverted. This is useful for meshes with inward-pointing normals.
    </Documentation>
  </Module>
  <Module name="DecimatePro"
          menu_name="Decimate"
          root_name="Deci"
          module_type="Filter"
          long_help="Simplify a polygonal model using an adaptive edge collapse algorithm.  This filter works with triangles only."
          short_help="Reduce the number of triangles in a model.">
    <Filter class="vtkDecimatePro">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Reduction target"
           trace_name="TargetReduction"
           property="TargetReduction"
           help="Value between 0 and 1. Desired reduction of the total number of triangles."
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0" display_value="0"/>
    <LabeledToggle label="Preserve topology"
                   trace_name="PreserveTopology"
                   property="PreserveTopology"
                   help="If off, better reduction can occur, but model may break up."/>
    <Scale label="Feature angle"
           trace_name="FeatureAngle"
           property="FeatureAngle"
           help="This angle is used to define a feature edge. (i.e., if the surface normal between two adjacent triangles is >= Feature angle, an edge exists). Topology can be split along feature edges."
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <LabeledToggle label="Boundary deletable"
                   trace_name="BoundaryVertexDeletion"
                   property="BoundaryVertexDeletion"
                   help="If off, decimate will not remove points on the boundary."/>
    <Documentation>
The Decimate filter reduces the number of triangles in a polygonal data set. Because this filter only operates on triangles, first run the Triangulate filter on a data set that contains polygons other than triangles. The Input menu allows the user to select the data set to which this filter will be applied. The Reduction target slider specifies the desired reduction in the total number of polygons (e.g., if the Reduction target value is 0.9, the Decimate filter will attempt to produce an output data set that is 10% the size of the input.) If the Preserve topology option is on, decimation will not split the data set or produce holes, but it may keep the filter from reaching the reduction target. The Feature angle slider value is used in determining where the data set may be split. If the angle between two adjacent triangles is >= the Feature angle value, then their boundary is considered a feature edge where the data set can be split. If the Boundary deletable option is on, then vertices on the boundary of the data set can be removed. Turning this option off preserves the boundary of the data set, but it may cause the filter not to reach its reduction target.
    </Documentation>
  </Module>
  <Module name="D3"
          menu_name="D3" root_name="D3"
          module_type="Filter"
          multiprocess_support="multiple_processes"
          long_help="Repartition a data set into load-balanced spatially convex regions.  Create ghost cells if requested."
          short_help="Repartition a data set.">
    <Filter class="vtkDistributedDataFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectionList label="Boundary Cells" property="BoundaryMode"
                   trace_name="BoundaryMode"
                   help="Select how to handle boundary cells. Isosurfacing works well when cells are uniquely assigned to processes. Dividing cells along processor boundaries is useful for volume rendering.">
      <Item name="Assign cells uniquely" value="0"/>
      <Item name="Duplicate cells" value="1"/>
      <Item name="Divide cells" value="2"/>
    </SelectionList>
    <StringEntry label="Global Node Id Array Name" property="GlobalNodeIdArrayName"
                 trace_name="GlobalNodeIdArrayName"
                 help="Provide name of global node (point) ID array so redistributed data does not duplicate node IDs" />
    <LabeledToggle label="Minimal memory"
                   trace_name="UseMinimalMemory" 
                   property="UseMinimalMemory" 
                   help="Force communication routines to use minimal memory, which is slower"/>
    <Documentation>
The D3 filter is available when ParaView is run in parallel. It operates on any type of data set to evenly divide it across the processors into spatially contiguous regions. The Boundary Cells menu determines how cells that lie on processor boundaries are handled. The Assign cells uniquely option assigns each boundary cell to exactly one process, which is useful for isosurfacing. Selecting Duplicate cells causes the cells on the boundaries to be copied to each process that shares that boundary. The Divide cells option breaks cells across process boundary lines so that pieces of the cell lie in different processes. This option is useful for volume rendering. The Global Id Array Name entry determines the name of the array containing global point ids. Such an array is necessary for processing ghost cells and is useful for removing duplicate points when merging sub-grids. The output of this filter is of type unstructured grid.
    </Documentation>
  </Module>
  <Module name="ElevationFilter"
          menu_name="Elevation"
          root_name="Elevation"
          module_type="Filter"
          long_help="Create point attribute array by projecting points onto an elevation vector."
          short_help="Create a point array representing elevation.">
    <Filter class="vtkElevationFilter">
      <Input name="Input"
             class="vtkDataSet">
        <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
  <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Scalar range"
                 trace_name="ScalarRange"
                 property="ScalarRange"
                 type="float" length="2"
                 help="Set the range of scalar values to generate" />
    <LineWidget trace_name="Line"
                point1_variable="LowPoint"
                point2_variable="HighPoint"
                point1_label="Low Point"
                point2_label="High Point"
                use_label="0"
                show_resolution="0"
                help="Set the minimum and maximum point for elevation"/>
    <Documentation>
The Elevation filter generates point scalar values for an input data set along a specified direction vector. The Input menu allows the user to select the data set to which this filter will be applied. Use the Scalar range entry boxes to specify the minimum and maximum scalar value to be generated. The Low Point and High Point define a line onto which each point of the data set is projected. The minimum scalar value is associated with the Low Point, and the maximum scalar value is associated with the High Point. The scalar value for each point in the data set is determined by the location along the line to which that point projects.
The line can be specified interactively using the 3D line widget. See section 7.4 for more information about this widget.
    </Documentation>
  </Module>

#if 1
  <Module name="CTHPart"
          menu_name="Extract CTH Parts"
          root_name="CTHPart"
          module_type="Filter"
          long_help="Create a surface from a CTH volume fraction."
          short_help="Extract a part from a CTH dataset.">
    <Filter class="vtkExtractCTHPart">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Cell" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectArrays filter_arrays="On"
                  deactivate="On"
                  field="Cell"
                  input_menu="im"
                  trace_name="ArraySelection"
                  property="AddVolumeArrayName"
                  help="Select the volume fraction arrays for generating parts."/>
    <SelectWidget property="ClipPlane"
                  trace_name="Clipping" label="Clip Plane">
      <Item label="Off" value="Off">
        <DummyWidget trace_name="Dummy"/>
      </Item>
      <Item label="On" value="On">
        <ImplicitPlaneWidget use_label="0" trace_name="Plane"
                             input_menu="im"
                             help="Adjusts the parameters of the plane to clip with."/>
      </Item>
    </SelectWidget>
    <Documentation>
Extract CTH Parts is a specialized filter for visualizing the data from a CTH simulation. It first converts the selected cell-centered arrays to point-centered ones. It then contours each array at a value of 0.5. The user has the option of clipping the resulting surface(s) with a plane.
If the Show All option is on, all the cell-centered scalar (single-component) arrays will be displayed in the array selection box; otherwise only the ones with "Fraction" or "fraction" in the name will be shown. (This behavior is because by default the CTH volume fraction arrays should be listed.) Clicking on the name of a particular array selects it. To choose multiple contiguous array names, click the first one and press the Shift key while clicking the last name you wish to select. If the names are not contiguous, press the Ctrl key while selecting the names from the list. The selected arrays will be contoured.
If you wish to clip the contour surfaces with a plane, select On from the menu in the Clipping section on this Parameters tab. You can interactively position and orient the plane using the plane widget. (See section 7.4 for the details of using this widget or manually setting the plane's parameters.)
This filter only operates on unstructured data. It produces polygonal output.
    </Documentation>
  </Module>
#endif
  <Module name="ExtractEdges"
          menu_name="Extract Edges"
          root_name="ExtractEdges"
          module_type="Filter"
          long_help="Extract edges of 2-d and 3-d cells as lines."
          short_help="Covert data to wireframe.">
    <Filter class="vtkExtractEdges">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Extract Edges filter produces a wireframe version of the input data set by extracting all the edges of the data set's cells as lines. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data set and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="ExtractParts"
          menu_name="Extract Parts"
          root_name="ExtractParts"
          module_type="Filter"
          long_help="Extract a subset of parts from a group."
          short_help="Extract a subset of parts from a group."
          button_image="PVUngroupButton"
          button_help="Separate parts from a group."
          button_visibility="0">
    <Filter class="vtkSelectInputs">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"  hide_gui="1"
               help="Set the input to this filter."
               input_name="Input"/>

    <ExtractPartsWidget trace_name="parts"
                        property="InputMask"
                        help="Choose the parts to extract."/>
    <Documentation>
The Extract Parts filter operates on any type of data, but its input reader/source/filter must have created multiple parts. The output type of this filter depends on the output type of the selected part(s). This filter is useful for operating on only a subset of the parts available from a reader, source, or filter.
    </Documentation>
  </Module>
  <Module name="DataSetSurfaceFilter"
          menu_name="Extract Surface"
          root_name="Surface"
          module_type="Filter"
          long_help="Extract a 2-d boundary surface using neighbor relations to eliminate internal faces."
          short_help="Extract 2-d boundary surface.">
    <Filter class="vtkDataSetSurfaceFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Piece Invariant"
                   trace_name="PieceInvariant"
                   property="PieceInvariant"
                   help="Turn this on to remove internal surface between processes. NOTE: Enabling this option might cause multiple executions of the data source because more information is needed to remove internal surfaces."/>
    <Documentation>
The Extract Surface filter extracts the polygons forming the outer surface of the input data set. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data and produces polygonal data as output.
    </Documentation>
  </Module>
  <Module name="Calculator"
          class="vtkPVSource"
          overide_autoaccept="1"
          root_name="Calc"
          button_image="PVCalculatorButton"
          button_help="Create new arrays using mathematical operations and existing arrays."
          module_type="Filter"
          long_help="Compute new attribute arrays as function of existing arrays."
          short_help="Compute new attribute arrays.">
    <Filter class="vtkArrayCalculator">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement/>
        <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <StringEntry property="ResultArrayName"
                 trace_name="ResultArray"
                 label="Result Array Name"
                 help="Set the name of the array to hold the results of this computation"/>
    <CalculatorWidget trace_name="Equation"
                      function_property="Function"
                      scalar_property="AddScalarVariable"
                      vector_property="AddVectorVariable"
                      attribute_mode_property="AttributeMode"
                      remove_all_variables_property="RemoveAllVariables"
                      help="Enter the equation for the new array."/>
    <LabeledToggle label="Replace invalid results"
                   trace_name="ReplaceInvalidValues"
                   property="ReplaceInvalidValues"
                   help="Replace invalid results."/>
    <VectorEntry label="Replacement value"
                 trace_name="ReplacementValue"
                 property="ReplacementValue"
                 type="float" length="1"
                 help="Set the value used instead of invalid values" />
    <Documentation>
The Calculator filter computes new data arrays as functions of existing scalar or vector arrays. The Input menu allows the user to select the data set to which this filter will be applied. The Result Array Name entry box allows the user to specify the name of the array containing the results of the computation. The Attribute Mode menu selects whether to operate on and produce results that are point-centered or cell-centered. If point-centered arrays are used, the resulting array will also be point-centered. The same is true for cell-centered arrays. The Calculator interface operates similarly to a scientific calculator. In creating the function to evaluate, the standard order of operations applies.
Each of the calculator functions is described below. Unless otherwise noted, enclose the operand in parentheses using the ( and ) buttons.
Clear: Erase the current function (displayed in the read-only text box above the calculator buttons).
/: Divide one scalar by another. The operands for this function are not required to be enclosed in parentheses.
*: Multiply two scalars, or multiply a vector by a scalar (scalar multiple). The operands for this function are not required to be enclosed in parentheses.
-: Negate a scalar or vector (unary minus), or subtract one scalar or vector from another. The operands for this function are not required to be enclosed in parentheses.
+: Add two scalars or two vectors. The operands for this function are not required to be enclosed in parentheses.
sin: Compute the sine of a scalar.
cos: Compute the cosine of a scalar.
tan: Compute the tangent of a scalar.
asin: Compute the arcsine of a scalar.
acos: Compute the arccosine of a scalar.
atan: Compute the arctangent of a scalar.
sinh: Compute the hyperbolic sine of a scalar.
cosh: Compute the hyperbolic cosine of a scalar.
tanh: Compute the hyperbolic tangent of a scalar.
x^y: Raise one scalar to the power of another scalar. The operands for this function are not required to be enclosed in parentheses.
sqrt: Compute the square root of a scalar.
e^x: Raise e to the power of a scalar.
log: Compute the logarithm of a scalar.
ceil: Compute the ceiling of a scalar.
floor: Compute the floor of a scalar.
abs: Compute the absolute value of a scalar.
v1.v2: Compute the dot product of two vectors. The operands for this function are not required to be enclosed in parentheses.
mag: Compute the magnitude of a vector.
norm: Normalize a vector.
The operands are described below.
The digits 0 - 9 and the decimal point are used to enter constant scalar values.
iHat, jHat, and kHat are vector constants representing unit vectors in the X, Y, and Z directions, respectively.
The scalars menu lists the names of the scalar arrays and the components of the vector arrays of either the point-centered or cell-centered data. The vectors menu lists the names of the point-centered or cell-centered vector arrays. The function will be computed for each point (or cell) using the scalar or vector value of the array at that point (or cell).
The filter operates on any type of data set, but the input data set must have at least one scalar or vector array. The arrays can be either point-centered or cell-centered. The Calculator filter's output is of the same data set type as the input.
The Calculator filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="FeatureEdges"
          menu_name="Feature Edges"
          root_name="FeatureEdges"
          module_type="Filter"
          replace_input="0"
          long_help="This filter will extract edges along sharp edges of surfaces or boundaries of surfaces."
          short_help="Extract edges that meet the feature critera.">
    <Filter class="vtkFeatureEdges">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Boundary edges"
                   trace_name="BoundaryEdges"
                   property="BoundaryEdges"
                   help="Turn this off if you do not want to extract boundary edges."/>
    <LabeledToggle label="Feature edges"
                   trace_name="FeatureEdges"
                   property="FeatureEdges"
                   help="Turn this off if you do not want to extract feature edges."/>
    <LabeledToggle label="Non-manifold edges"
                   trace_name="NonManifoldEdges"
                   property="NonManifoldEdges"
                   help="Turn this off if you do not want to extract non-manifold edges."/>
    <LabeledToggle label="Manifold edges"
                   trace_name="ManifoldEdges"
                   property="ManifoldEdges"
                   help="Turn this on if you want to extract manifold edges."/>
    <LabeledToggle label="Coloring"
                   trace_name="Coloring"
                   property="Coloring"
                   help="Turn this off if you do not want to color the edges by type."/>
    <Scale label="Feature angle"
           trace_name="FeatureAngle"
           property="FeatureAngle"
           help="This angle is used to define a feature edge. (i.e., if the surface normal between two adjacent triangles is >= Feature angle, an edge exists).."
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Feature Edges filter extracts various subsets of edges from the input data set. Which edges are extracted depends on which check boxes are marked. The four types of edges are as follows.
Boundary edges: line cells or edges used by only one polygon
Feature edges: edges used by two polygons whose dihedral angle > the value from the Feature angle slider
Non-manifold edges: edges used by three or more polygons
Manifold edges: edges used by exactly two polygons
If the Coloring option is checked, then the extracted edges are assigned a scalar value based on the type of the edge. The Input menu allows the user to select the data set to which this filter will be applied.
This filter operates on polygonal data and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="Gradient"
          menu_name="Gradient" root_name="Grad"
          module_type="Filter">
    <Filter class="vtkImageGradient">
      <Input name="Input"
             class="vtkImageData">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectionList property="Dimensionality"
                   trace_name="Dimensionality"
                   label="Dimensionality"
                   help="Select whether to perform a 2d or 3d gradient">
      <Item name="2"
            value="2"/>
      <Item name="3"
            value="3"/>
    </SelectionList>
    <Documentation>
The Gradient filter computes the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu determines from which scalar array the gradient will be computed. The Dimensionality menu selects whether the gradient will be calculated in 2 or 3 dimensions. If only 2 dimensions are used, gradients are only computed in X and Y. This filter uses central differences to compute the gradients. The Gradient filter operates on uniform rectilinear (image) data and produces image data output.
    </Documentation>
  </Module>
  <Module name="UnstructuredGradient"
          menu_name="Gradient (Unstructured)" root_name="UGrad"
          module_type="Filter">
    <Filter class="vtkGradientFilter">
      <Input name="Input" class="vtkPointSet">
        <ArrayRequirement components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <FieldMenu id="fm" trace_name="FieldMenu" input_menu="im"
               property="SelectInputScalars"
               help="Choose the scalar array to compute gradients from."/>
    <ArrayMenu id="am" property="SelectInputScalars"
               trace_name="Scalars" label="Scalars" field_menu="fm"
               help="Choose the threshold scalar array."/>
    <StringEntry label="Result Array Name" property="ResultArrayName"
                 trace_name="ResultArrayName"
                 help="Provide a name for the output array containing the gradient vectors." />
    <Documentation>
The Gradient filter estimates the gradient vector at each point or cell.  The Input menu allows the user to select the data set to which this filter will be applied.  The Field and Scalars menus allow the user to select the scalar array from which to compute gradients.  The Scalars menu determines from which scalar array the gradient will be computed.  The Result Array Name box allows the user to specify the name of the output array holding the computed gradients.
    </Documentation>
  </Module>
  <Module name="GradientMagnitude"
          menu_name="Gradient Magnitude"
          root_name="GradM"
          module_type="Filter">
    <Filter class="vtkImageGradientMagnitude">
      <Input name="Input"
             class="vtkImageData">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectionList property="Dimensionality"
                   trace_name="Dimensionality"
                   label="Dimensionality"
                   help="Select whether to perform a 2d or 3d gradient magnitude">
      <Item name="2"
            value="2"/>
      <Item name="3"
            value="3"/>
    </SelectionList>
    <Documentation>
The Gradient Magnitude filter computes the magnitude of the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu allows the user to select which scalar array will be used for gradient magnitude calculations. The Dimensionality menu determines whether the gradient magnitude will be computed in 2 or 3 dimensions. If 2 dimensions are used, the gradient magnitude will be computed from the gradients in X and Y. This filter operates on uniform rectilinear (image) data and produces image data output.
    </Documentation>
  </Module>
  <Module name="GroupParts"
          menu_name="Group Parts"
          root_name="GroupParts"
          module_type="Filter"
          replace_input="1"
          long_help="Group parts."
          short_help="Group multiple inputs into one collection."
          button_image="PVGroupButton"
          button_help="Group multiple modules into one."
          button_visibility="0">
    <Filter class="vtkGroup">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple"/>
    </Filter>
    <GroupInputsWidget trace_name="inputs" property="Input"
                       help="Choose inputs to group."/>
    <Documentation>
The Group Parts filter causes different data sets to be grouped into a collection and treated as a single data set for filtering purposes. All the data objects currently in ParaView will appear in the selection list. Only visible data objects are selected by default. To select a single data set, click on its name. To select several sources whose names are contiguous in the list, select the first name, press and hold the Shift key, and (while still holding the Shift key) click the last name. To select several data sets whose names are non-contiguous, press and hold the Ctrl key while clicking the names. This filter operates on any type of data. The output type depends on the data sets selected for grouping.
    </Documentation>
  </Module>
  
  <Module name="LinearExtrusionFilter"
          menu_name="Linear Extrusion"
          root_name="LinExtrude"
          module_type="Filter"
          long_help="This filter creates a swept surface defined by translating the input along a vector."
          short_help="Generate a linear swept surface.">
    <Filter class="vtkPVLinearExtrusionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- ScaleFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Scale factor"
                 trace_name="ScaleFactor"
                 property="ScaleFactor" type="float"
                 help="Set the extrusion scale factor"/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Vector"
                 trace_name="Vector"
                 property="Vector"
                 type="float" length="3"
                 help="Set the direction for the extrusion"/>
    <LabeledToggle label="Capping"
                   trace_name="Capping"
                   property="Capping"
                   help="Select whether to draw endcaps"/>
    <LabeledToggle label="Piece invariant"
                   trace_name="PieceInvariant"
                   property="PieceInvariant"
                   help="Turn this off if you do want to process ghost levels and do not mind seams."/>
    <Documentation>
The Linear Extrusion filter creates a swept surface by translating the input data set along a specified vector. This filter is intended to operate on 2D polygonal data. The Input menu allows the user to select the data set to which this filter will be applied. The three Vector entry boxes specify the X, Y, and Z components of the vector along which to sweep the input. The value of the Scale factor entry determines the distance along the vector the data set will be translated. (A scale factor of 0.5 will move the data set half the length of the vector, and a scale factor of 2 will move it twice the vector's length.)
The Capping check box indicates whether to cap the ends of the swept surface. Capping works by placing a copy of the input data set on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input data set is a closed solid (e.g., a sphere), then if capping is on, two copies of the data set will be displayed on output (the second translated from the first one along the specified vector). If instead capping is off, then an input closed solid will produce no output.
The Piece invariant check box determines whether the output will be the same regardless of the number of processors used to compute the result. The difference is whether there are internal polygonal faces on the processor boundaries. This filter operates on polygonal data and produces polygonal data output.
    </Documentation>
  </Module>
  <Module name="LoopSubdivisionFilter"
          menu_name="Loop Subdivision"
          root_name="LoopSubDiv"
          module_type="Filter"
          long_help="This filter iteratively divides each triangle into four triangles.  New points are placed so the output surface is smooth."
          short_help="Create a higher resolution and smoother surface.">
    <Filter class="vtkLoopSubdivisionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Number of divisions"
           trace_name="NumberOfSubdivisions"
           property="NumberOfSubdivisions"
           help="Each subdivision changes single triangles into four triangles."
           resolution="1"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Loop Subdivision filter increases the granularity of a polygonal mesh. It works by dividing each triangle in the input into four new triangles. It is named for Charles Loop, the person who devised this subdivision scheme. This filter only operates on triangles, so a data set that contains other types of polygons should be passed through the Triangulate filter before applying this filter to it. The Input menu allows the user to select the data set to which this filter will be applied. The Number of divisions slider specifies the number of subdivision iterations to be performed. (For example, if the number of divisions is 2, the triangles in the initial mesh will each be divided into four new triangles. Then those new triangles will be further subdivided.) This filter only operates on polygonal data (specifically triangle meshes), and it produces polygonal output.
    </Documentation>
  </Module>
  <Module name="MaskPoints"
          menu_name="Mask Points"
          root_name="MaskPts"
          module_type="Filter"
          long_help="Reduce the number of points.  This filter is often used before glyphing.  Generating vertices is an option."
          short_help="Reduce the number of points.">
   <Filter class="vtkMaskPoints">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ThumbWheel label="On ratio"
                trace_name="OnRatio"
                property="OnRatio"
                resolution="1"
                minimum_value="1"
                help="The ratio of points retained."/>
    <ThumbWheel label="Max. points"
                trace_name="MaximumNumberOfPoints"
                property="MaximumNumberOfPoints"
                help="Limit the number of points."
                resolution="1"
                minimum_value="0"/>
    <ThumbWheel label="Offset"
                trace_name="Offset"
                proeprty="Offset"
                resolution="1"
                minimum_value="0"
                help="Start with this point."/>
    <LabeledToggle label="Random" trace_name="Random"
                   property="RandomMode"
                   help="Select whether to randomly select points, or subsample regularly."/>
    <LabeledToggle label="Generate vertices"
                   trace_name="GenerateVertices"
                   property="GenerateVertices"
                   help="Convienience feature to display points."/>
    <Documentation>
The Mask Points filter reduces the number of points in the data set. It operates on any type of data set, but produces only points / vertices. This filter is often used before the Glyph filter, but now the basic point-masking functionality is available on the Parameters page for the Glyph filter.
The Input menu allows the user to select the data set to which this filter will be applied. The value in the On ratio thumb wheel specifies the ratio of points to retain in the output. (For example, if the on ratio is 3, then the output will contain 1/3 as many points -- up to the Max. points value -- as the input.) The Max. points thumb wheel determines the maximum number of points that will appear in the output. The Offset thumb wheel specifies the point in the data set from which to start masking. If the Random check box is marked, then the output points will be selected randomly from the input; otherwise every nth point (specified by the on ratio) will be selected. Selecting points at random is helpful to avoid striping when masking the points of a structured data set. If the Generate vertices option is checked, then a vertex cell will be created for each point in the output.
    </Documentation>
  </Module>
  <Module name="Median"
          root_name="Median" module_type="Filter">
    <Filter class="vtkImageMedian3D">
      <Input name="Input"
             class="vtkImageData">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Kernel Size"
                 trace_name="KernelSize"
                 property="KernelSize" type="int"
                 length="3"
                 help="Determines the smoothing neighborhood."/>
    <Documentation>
The Median filter operates on uniform rectilinear (image or volume) data and produces uniform rectilinear output. It replaces the scalar value at each pixel / voxel with the median scalar value in the specified surrounding neighborhood (Kernel Size). From the Input menu, the user can select the data set on which to perform this calculation. The Scalar menu determines which scalar array will be used to determine the median. The Kernel Size entry boxes specify the number of pixels / voxels in each dimension to use in computing the median to assign to each pixel / voxel. If the kernel size in a particular dimension is 1, then the median will not be computed in that direction. Since the median operation removes outliers, this filter is useful for removing high-intensity, low-probability noise (shot noise).
    </Documentation>
  </Module>
  <Module name="MeshQuality"
          class="vtkPVSource"
          root_name="Quality"
          menu_name="Mesh Quality"
          module_type="Filter"
          long_help="Compute the quality of triangular, quadrilateral, and tetrahedral cells in a mesh."
          short_help="Compute the quality of the cells in a mesh.">
    <Filter class="vtkMeshQuality">
      <Input name="Input"
             class="vtkDataSet">
      </Input>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectionList property="TriangleQualityMeasure"
                   trace_name="TriangleQualityMeasure"
                   label="Triangle Quality Measure"
                   help="Select the quality measure used to evaluate triangle quality. The radius ratio is the size of a circle circumscribed by a triangle's 3 vertices divided by the size of a circle tangent to a triangle's 3 edges. The edge ratio is the ratio of the longest edge length to the shortest edge length.">
      <Item name="Edge Ratio" value="0"/>
      <Item name="Aspect Ratio" value="1"/>
      <Item name="Radius Ratio" value="2"/>
      <Item name="Frobenius Norm" value="3"/>
      <Item name="Minimal Angle" value="6"/>
    </SelectionList>
    <SelectionList property="QuadQualityMeasure"
                   trace_name="QuadQualityMeasure"
                   label="Quadrilateral Quality Measure"
                   help="Select the quality measure used to evaluate quadrilateral quality">
      <Item name="Edge Ratio" value="0"/>
      <Item name="Aspect Ratio" value="1"/>
      <Item name="Radius Ratio" value="2"/>
      <Item name="Average Frobenius Norm" value="4"/>
      <Item name="Maximal Frobenius Norm" value="5"/>
      <Item name="Minimal Angle" value="6"/>
    </SelectionList>
    <SelectionList property="TetQualityMeasure"
                   trace_name="TetQualityMeasure"
                   label="Tet Quality Measure"
                   help="Select the quality measure used to evaluate tetrahedral quality. The radius ratio is the size of a sphere circumscribed by a tetrahedron's 4 vertices divided by the size of a circle tangent to a tetrahedron's 4 faces. The edge ratio is the ratio of the longest edge length to the shortest edge length.">
      <Item name="Edge Ratio" value="0"/>
      <Item name="Aspect Ratio" value="1"/>
      <Item name="Radius Ratio" value="2"/>
      <Item name="Frobenius Norm" value="3"/>
      <Item name="Minimal Dihedral Angle" value="6"/>
    </SelectionList>
    <Documentation>
The mesh quality filter computes the quality of individual triangles, quadrilaterals, tetrahedra and hexahedra in a data set. Several quality measures exist for the different cell types. You may choose one for each type of cell. The filter then adds a new scalar array named "Quality" to the per-cell values of the data set containing these measures. Typically, a value of 1 is the optimal quality and the higher the value, the lower the cell quality.
    </Documentation>
  </Module>
  <Module name="PolyDataNormals"
          menu_name="Normals generation"
          root_name="PDNormals"
          module_type="Filter"
          long_help="This filter will produce surface normals used for smooth shading.  Spltting is used to avoid smoothing across feature edges."
          short_help="Produce surface point normals.">
    <Filter class="vtkPPolyDataNormals">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Feature angle"
           trace_name="FeatureAngle"
           property="FeatureAngle"
           help="Points are duplicated along features over this angle (0->180)"
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0" display_value="0"/>
    <LabeledToggle label="Splitting"
                   trace_name="Splitting"
                   property="Splitting"
                   help="Turn on/off the splitting of sharp edges."/>
    <LabeledToggle label="Consistency"
                   trace_name="Consistency"
                   property="Consistency"
                   help="Turn on/off the enforcement of consistent polygon ordering."/>
    <LabeledToggle label="Flip normals"
                   trace_name="FlipNormals"
                   property="FlipNormals"
                   help="Flipping reverves the meaning of front and back."/>
    <LabeledToggle label="Non-manifold"
                   trace_name="NonManifoldTraversal"
                   property="NonManifoldTraversal"
                   help="Turn on/off traversal across non-manifold edges. This will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops."/>
    <LabeledToggle label="Cell normals"
                   trace_name="ComputeCellNormals"
                   property="ComputeCellNormals"
                   help="Turn on/off the computation of cell normals."/>
    <LabeledToggle label="Piece invariant"
                   trace_name="PieceInvariant"
                   property="PieceInvariant"
                   help="Turn this off if you do not want to process ghost levels and do not mind seams."/>
    <Documentation>
The Normals generation filter generates surface normals at the points of the input polygonal data set to provide smooth shading of the data set. The resulting data set is also polygonal. The filter works by calculating a normal vector for each polygon in the data set and then averaging the normals at the shared points.
In creating surface normals, if the angle between two polygons at a shared edge is larger than the value of the Feature angle slider, then that edge is considered a feature edge. If Splitting is turned on, then the mesh will be split along feature edges, allowing points to be duplicated. Because the duplicated points are no longer shared between the polygons meeting at the feature edge, a normal at these points will be created per polygon rather than averaging the polygon normals to produce one normal at each point. This allows the feature edges to remain "sharp" after shading.
Generally the normals for a data set should either all point inward or all point outward. If the Consistency check is on, then this filter will reorder the points of cells that whose normal vectors are oriented the opposite direction from the rest of those in the data set. If the Flip normals option is checked, this filter will reverse the normal direction (and reorder the points) for all polygons in the data set. You might want to do this if your viewing position will be inside the data set instead of outside of it. Sometimes you may have more than two polygons sharing an edge (i.e., a non-manifold edge). When this is the case and the Consistency option is checked, then if the Non-manifold check is on, this filter will try to maintain consistent normals across non-manifold edge, but doing this can corrupt the ordering of polygons at these edges.
This filter computes the normals at the points in the data set. In the process of doing this it computes polygon normals too. If you want these normals to be passed to the output of this filter, turn on the Cell normals option.
If this filter is run in parallel, the resulting data set will have seams along the processor boundaries unless the Piece invariant check box is marked.
    </Documentation>
  </Module>
  <Module name="OutlineFilter"
          menu_name="Outline"
          root_name="Outline"
          module_type="Filter"
          replace_input="0"
          long_help="This filter generates a bounding box representation of the input."
          short_help="Generates a bounding box.">
    <Filter class="vtkPOutlineFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on any type of data set and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="OutlineCornerFilter"
          menu_name="Outline Corners"
          root_name="COutline"
          module_type="Filter"
          replace_input="0"
          long_help="This filter generates a bounding box representation of the input.  It only displays the corners of the bounding box."
          short_help="Generates corners of a bounding box.">
    <Filter class="vtkPOutlineCornerFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Corner factor"
           trace_name="CornerFactor"
           property="CornerFactor"
           help="The relative size of the corners to the length of the corresponding bounds. (0.001 -> 0.5)"
           resolution="0.001"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Outline Corners filter generates the corners of a bounding box for the input data set (specified by the Input menu). The Corner factor slider specifies the relative length of the corners along the corresponding edges. This filter produces polygonal output.
    </Documentation>
  </Module>
  <Module name="PartScalars"
          menu_name="Part Id Scalars"
          root_name="ColorParts"
          module_type="Filter"
          long_help="This filter uses colors to show how data is partitioned across parts."
          short_help="Generate point scalars from part id.">
    <Filter class="vtkColorByPart">
      <Input name="Input"
             class="vtkDataSet"
             quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"  hide_gui="1"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Part Id Scalars filter assigns a unique scalar value to each part in the input. The input parts must have been collected together either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
    </Documentation>
  </Module>

  <Module name="OctreeDepthScalars"
          menu_name="Octree Depth Scalars"
          root_name="OctreeDepth"
          module_type="Filter"
          long_help="This filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree."
          short_help="Computes cell depths within the octree.">
    <Filter class="vtkHyperOctreeDepth">
      <Input name="Input"
             class="vtkHyperOctree"
             quantity="Single">
        <GroupRequirement quantity="Single"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The vtkHyperOctreeDepth filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree.
    </Documentation>
  </Module>

  <Module name="OctreeDepthLimit"
          menu_name="Octree Depth Limit"
          root_name="OctreeLimit"
          module_type="Filter"
          long_help="This filter takes in a octree and produces a new octree which is no deeper than the maximum specified depth level."
          short_help="Reduce an octree's resolution.">
    <Filter class="vtkHyperOctreeLimiter">
      <Input name="Input"
             class="vtkHyperOctree"
             quantity="Single">
        <GroupRequirement quantity="Single"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
      <VectorEntry label="MaximumLevel" 
                   trace_name="MaximumLevel"
                   property="MaximumLevel" 
                   type="int"
                   help="Set the maximum depth of the output."/>
    <Documentation>
The vtkHyperOctreeLimiter takes in a octree and produces a new octree in which is nowhere deeper than the maximum specified depth level. The attribute data of pruned leaf cells is integrated in to their ancestors at the cut level.
    </Documentation>
  </Module>
  <Module name="ProcessIdScalars"
          menu_name="Process Id Scalars"
          root_name="PIScalars"
          module_type="Filter"
          multiprocess_support="multiple_processes"
          long_help="This filter uses colors to show how data is partitioned across processes."
          short_help="Generate point scalars from process id.">
    <Filter class="vtkProcessIdScalars">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Random"
                   trace_name="RandomMode"
                   property="RandomMode"
                   help="Select whether to use random colors for the various pieces"/>
    <Documentation>
The Process Id Scalars filter assigns a unique scalar value to each piece of the input according to which processor it resides on. If the Random option is selected, the unique value per piece will be chosen at random; otherwise it will match the process id. This filter operates on any type of data when ParaView is run in parallel. It is useful for determining whether your data is load-balanced across the processors being used. The output data set type is the same as that of the input.
    </Documentation>
  </Module>
  <Module name="PointDataToCellData"
          root_name="PointToCell"
          menu_name="Point Data to Cell Data"
          module_type="Filter"
          long_help="Create cell attributes by averaging point attributes."
          short_help="Convert point data to cell data.">
    <Filter class="vtkPointDataToCellData">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Point"/>
      <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Pass point data"
                   trace_name="PassPointData"
                   property="PassPointData"
                   help="If on, then the input point data is passed through to the output; otherwise, only generated cell data is placed into the output."/>
    <Documentation>
The Point Data to Cell Data filter averages the values of the point attributes of the points of a cell to compute cell attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass point data option is checked, then the input point attributes will also be copied to the point attributes of the output; otherwise the output will only have cell attributes. The Point Data to Cell Data filter operates on any type of data set, and the output data set is of the same type as the input.
    </Documentation>
  </Module>
  <Module name="QuadricClustering"
          menu_name="Quadric Clustering"
          root_name="QC"
          module_type="Filter"
          long_help="This filter is the same filter used to generate level of detail for ParaView.  It uses a structured grid of bins and merges all points contained in each bin."
          short_help="Simplify polygonal models.">
    <Filter class="vtkQuadricClustering">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Divisions"
                 trace_name="NumberOfDivisions"
                 property="NumberOfDivisions"
                 type="int"
                 length="3"
                 help="Set the number of bins in each dimension"/>
    <LabeledToggle label="Use input points"
                   trace_name="UseInputPoints"
                   property="UseInputPoints"
                   help="Select whether to use points from the input in the output or to calculate optimum representative points for each bin"/>
    <LabeledToggle label="Use feature edges"
                   trace_name="UseFeatureEdges"
                   property="UseFeatureEdges"
                   help="Select whether to use feature edge quadrics to match up the boundaries between pieces"/>
    <LabeledToggle label="Use feature points"
                   trace_name="UseFeaturePoints"
                   property="UseFeaturePoints"
                   help="Select whether to use feature point quadrics to align piece boundaries"/>
    <LabeledToggle label="Copy cell data"
                   trace_name="CopyCellData"
                   property="CopyCellData"
                   help="Should cell data be copied from output to input?"/>
    <Documentation>
The Quadric Clustering filter produces a reduced-resolution polygonal approximation of the input polygonal data set. This filter is the one used by ParaView for computing LODs. It uses spatial binning to reduce the number of points in the data set; points that lie within the same spatial bin are collapsed into one representative point. The Divisions entries specify the number of bins along the X, Y, and Z axes of the data set. If Use input points is on, the representative point for each bin is selected from one of the input points that lies in that bin; the input point that produces the least error is chosen. Without this option selected, the location of the representative point is calculated to produce the least error possible for that bin, but the point will most likely not be one of the input points.
To better align pieces of the data set assigned to different processors, select Use feature edges and Use feature points. Use feature edges adjusts the representative points that contain boundary edges (along processor divisions), and Use feature points further influences the position of the feature points along the boundaries.
The Copy cell data toggle controls whether cell-centered data from the input should be copied to the output.
    </Documentation>
  </Module>
  <Module name="BrownianPoints"
          menu_name="Random Vectors"
          root_name="BPts"
          module_type="Filter"
          long_help="This filter creates a new 3 component point data array and sets it as the default vectors.  It uses a random number generator to create values."
          short_help="Create a new random vector array.">
    <Filter class="vtkBrownianPoints">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ThumbWheel label="Min. speed"
                trace_name="MinimumSpeed"
                property="MinimumSpeed"
                resolution="0.01"
                minimum_value="0"
                help="The minimum size of the random point vectors generated."/>
    <ThumbWheel label="Max. speed"
                trace_name="MaximumSpeed"
                property="MaximumSpeed"
                resolution="0.01"
                minimum_value="0"
                help="The maximum size of the random point vectors generated."/>
    <Documentation>
The Random Vectors filter generates a point-centered array of random vectors. It uses a random number generator to determine the components of the vectors. The Min. speed and Max. speed values determine the range of the vector magnitudes. This filter operates on any type of data set, and the output data set will be of the same type as the input.
    </Documentation>
  </Module>
  <Module name="ReflectionFilter"
          menu_name="Reflection"
          root_name="Reflect"
          module_type="Filter"
          long_help="This filter takes the union of the input and its reflection over an axis-aligned plane."
          short_help="Reflect input over an axis aligned plane.">
    <Filter class="vtkReflectionFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectionList property="Plane"
                   trace_name="Plane"
                   label="Plane"
                   help="Select which plane of the bounding box to reflect across">
      <Item name="X"
            value="6"/>
      <Item name="Y"
            value="7"/>
      <Item name="Z"
            value="8"/>
      <Item name="X Min"
            value="0"/>
      <Item name="Y Min"
            value="1"/>
      <Item name="Z Min"
            value="2"/>
      <Item name="X Max"
            value="3"/>
      <Item name="Y Max"
            value="4"/>
      <Item name="Z Max"
            value="5"/>
    </SelectionList>
    <!-- reasonable value dependent on bounds of the data -->
    <VectorEntry label="Center"
                 trace_name="Center"
                 property="Center"
                 type="float"
                 help="The center of the mirror plane."/>
    <LabeledToggle property="CopyInput" trace_name="CopyInput"
                   label="Copy Input"
                   help="Include both the input and its reflection in the output."/>
    <Documentation>
The Reflection filter reflects the input data set across the specified plane. If the Copy Input check box is marked, the output is the union of the input data set and its reflection. Otherwise the output will contain only the reflection of the input data. If the value chosen from the Plane menu is X, Y, or Z, the value of the Center entry determines where the plane is placed along the specified axis. The other six entries, X Min, X Max, etc., place the reflection plane at the specified face of the bounding box of the input data set. This filter operates on any type of data set and produces an unstructured grid output.
    </Documentation>
  </Module>
  <Module name="RibbonFilter"
          menu_name="Ribbon"
          root_name="Ribbon"
          module_type="Filter"
          long_help="This filter generates ribbon surface from lines.  It is useful for displaying streamlines."
          short_help="Create ribbon surfaces from lines.">
    <Filter class="vtkRibbonFilter">
      <Input name="Input"
             class="vtkPolyData">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu property="SelectInputVectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               help="Select the input normals to process."/>
    <ArrayMenu property="SelectInputScalars"
               trace_name="Scalars"
               label="Scalars"
               input_menu="im"
               help="Select the input scalars to process."/>
    <ScaleFactorEntry label="Width"
                      property="Width"
                      input_menu="im"
                      trace_name="Width"
                      help="The half width of the ribbon (or minimum)."/>
    <Scale label="Angle"
           trace_name="Angle"
           property="Angle"
           help="The offset angle of the ribbon from the line normal (0->360)."
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <LabeledToggle label="Use default normal"
                   trace_name="UseDefaultNormal"
                   property="UseDefaultNormal"
                   help="When this option is off, default normals will be generated if the input contains no normals. If on, the Default normal will be used."/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Default normal"
                 trace_name="DefaultNormal"
                 property="DefaultNormal"
                 type="float"
                 length="3"
                 help="Specify the normal to use if Use default normal is on."/>
    <LabeledToggle label="Vary width"
                   trace_name="VaryWidth"
                   property="VaryWidth"
                   help="Turn on/off the variation of ribbon width with scalar value."/>
    <Documentation>
The Ribbon filter creates ribbons from the lines in the input data set. This filter is useful for visualizing streamlines. Both the input and output of this filter are polygonal data. The input data set must also have at least one point-centered vector array.
The vectors and scalars for use in this filter can be selected from the Vectors and Scalars menus respectively. If the Vary width option is on, the width of the ribbons will be scaled according to the selected scalars. If Use default normal is off, the selected vector array will be used as the normals of the ribbons. If Use default normal is on, the normal for the ribbons is specified by the values in the Default normal entry boxes.
The Width entry box specifies half the width of the ribbons. If Vary width is on, then the Width value specified is half the minimum width of the ribbons. The Angle value determines the orientation of the ribbons; it specifies the offset angle (in degrees) of the ribbon from the normal line.
    </Documentation>
  </Module>
  <Module name="RotationalExtrusionFilter"
          menu_name="Rotational Extrusion"
          root_name="RotExtrude"
          module_type="Filter"
          long_help="This filter generates a swept surface while translates the input along a circular path."
          short_help="Generates a swept surface using a rotational path.">
    <Filter class="vtkRotationalExtrusionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ThumbWheel label="Resolution"
                trace_name="Resolution"
                property="Resolution"
                resolution="1"
                minimum_value="1"/>
    <LabeledToggle label="Capping"
                   trace_name="Capping"
                   property="Capping"/>
    <VectorEntry label="Angle"
                 trace_name="Angle"
                 property="Angle"
                 help="Set the angle of rotation."
                 type="float"/>
    <!-- Translation value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Translation"
                 trace_name="Translation"
                 property="Translation"
                 type="float"
                 help="The total amount of translation along the z-axis."/>
    <!-- DeltaRadius value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Delta radius"
                 trace_name="DeltaRadius"
                 property="DeltaRadius"
                 type="float"
                 help="The change in radius during sweep process."/>
    <Documentation>
The Rotational Extrusion filter forms a surface by rotating the input about the Z axis. This filter is intended to operate on 2D polygonal data. The Input menu allows the user to select the data set to which this filter will be applied. The value of the Resolution thumb wheel specifies the number of steps taken in rotating from 0 to the value specified in the Angle entry box. The Translation entry box determines the distance along the Z axis to be covered as the data set is rotated. Specifying a non-zero Translation value allows you to create a corkscrew or spring effect. The Delta radius entry box controls how much the radius of the rotation increases as the new data set is swept out.
The Capping check box controls whether to close the open ends of the swept surface. Capping works by placing a copy of the input data set on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input data set is a closed solid (e.g., a sphere), then either two copies of the data set will be drawn or no surface will be drawn. No surface is drawn if either capping is on or if the two surfaces would occupy exactly the same 3D space (e.g., Angle is a multiple of 360, and Translation and Delta radius are 0).
    </Documentation>
  </Module>
  <Module name="ShrinkFilter"
          menu_name="Shrink"
          root_name="Shrink"
          module_type="Filter"
          long_help="This filter shrinks each input cell so they pull away from their neighbors."
          short_help="Shrink each input cell.">
    <Filter class="vtkShrinkFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Shrink factor"
           trace_name="ShrinkFactor"
           property="ShrinkFactor"
           help="Set the amount to shrink by"
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Shrink filter causes the individual cells of a data set to break apart from each other by moving each cell's points toward the centroid of the cell. (The centroid of a cell is the average position of its points.) The Shrink factor scale determines how far the points will move. A value of 0 positions the points at the centroid of the cell; a value of 1 leaves them at their original positions. This filter operates on any type of data set and produces unstructured grid output.
    </Documentation>
  </Module>
    <!--
  <Module name="ShrinkPolyData"
          menu_name="Shrink (polygons)"
          root_name="ShrinkPD" module_type="Filter"
          long_help="This filter shrinks each input cell so they pull away from their neighbors.  The output is always of type unstructured grid."
          short_help="Shrink each input cell.">
    <Filter class="vtkShrinkPolyData">
      <Input name="Input"
             class="vtkPolyData" />
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <VectorEntry label="Shrink factor"
                 trace_name="ShrinkFactor"
                 property="ShrinkFactor"
                 type="float"
                 help="Set the amount to shrink by"/>
  </Module>
    -->
  <Module name="SmoothPolyDataFilter"
          menu_name="Smooth"
          root_name="Smooth"
          module_type="Filter"
          long_help="This filter smooths a polygonal surface by iteratively moving points toward their neighbors."
          short_help="Smooth a polygonal surface without adding more points.">
    <Filter class="vtkSmoothPolyDataFilter">
      <Input name="Input"
           class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ThumbWheel label="Num. iterations"
                trace_name="NumberOfIterations"
                property="NumberOfIterations"
                resolution="1"
                minimum_value="0"
                help="Number of iterations. More iterations produce better smoothing."/>
    <Scale label="Convergence"
           trace_name="Convergence"
           property="Convergence"
           help="Convergence criterion for the iteration process. Smaller numbers result in more smoothing iterations (0->1)."
           resolution="0.01"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Smooth filter operates on a polygonal data set by iteratively adjusting the position of the points using Laplacian smoothing. (Because this filter only adjusts point positions, the output data set is also polygonal.) This results in better-shaped cells and more evenly distributed points. The Num. iterations thumb wheel specifies the maximum number of smoothing iterations to perform. The Convergence slider limits the maximum motion of any point. It is expressed as a fraction of the length of the diagonal of the bounding box of the data set. If the maximum point motion during a smoothing iteration is less than the Convergence value, the smoothing operation terminates.
    </Documentation>
  </Module>
  <Module name="Stripper"
          menu_name="Triangle Strips"
          root_name="Strip"
          module_type="Filter"
          long_help="This filter uses a greedy algorithm to convert triangles into triangle strips"
          short_help="Convert triangles into triangle strips.">
    <Filter class="vtkStripper">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Max. length"
           trace_name="MaximumLength"
           property="MaximumLength"
           help="Stop stripping after this many triangles."
           resolution="1"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Triangle Strips filter converts triangles into triangle strips and lines into polylines. The Max. length slider determines the maximum number of triangles or lines to merge into a strip. This filter operates on polygonal data sets and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="Subdivide"
          root_name="Subdivide"
          module_type="Filter"
          long_help="This filter iteratively divide triangles into four smaller triangles.  New points are placed linearly so the output surface matches the input surface."
          short_help="Creates a surface with more triangles than the input.">
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Num. divisions"
           trace_name="NumberOfSubdivisions"
           property="NumberOfSubdivisions"
           help="Set the number of subdivisions"
           resolution="1"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Filter class="vtkLinearSubdivisionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <Documentation>
The Subdivide filter iteratively divides each triangle in the data set into 4 new triangles. Three new points are added per triangle -- one at the midpoint of each edge. The image below shows a triangle with the new points inserted and the appropriate edges added to form the four new triangles. The Num. divisions slider determines the number of subdivision passes the filter will take through the data. This filter operates only on polygonal data containing triangles, so run your polygonal data through the Triangulate filter first if it is not composed of triangles. The output of this filter is also polygonal.
    </Documentation>
  </Module>
  <Module name="TessellatorFilter" menu_name="Tessellate" root_name="TessellatorFilter" module_type="Filter"
          long_help="Tessellate nonlinear curves, surfaces, and volumes with lines, triangles, and tetrahedra."
          short_help="Polygonize a mesh.">
    <Filter class="vtkTessellatorFilter">
      <Input name="Input" class="vtkPolyData"/>
      <Input name="Input" class="vtkDataSet"/>
      <Input name="Input" class="vtkUnstructuredGrid"/>
    </Filter>
    <InputMenu label="Input" trace_name="Input" id="tess_source_select"
               property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Output Dimension" trace_name="OutputDimension"
           property="OutputDimension"
           help="Maximum dimensionality of output tessellation. Cells of higher dimension will be reduced to their boundaries."
           display_entry="0" entry_and_label_on_top="1" display_value="1"
           />
    <VectorEntry label="Max Chord Error"
                 trace_name="ChordError"
                 property="ChordError" type="float"
                 help="The maximum chord error allowed at any edge midpoint in the output tessellation."
                 />
    <TempTessellatorEntry label="Max Field Error" trace_name="FieldError2"
                      property="FieldError2"
                      help="The maximum field error allowed at any edge midpoint in the output tessellation."
                      input_menu_id="tess_source_select"
                      />
    <VectorEntry label="Max Num Of Subdivisions"
                 trace_name="MaximumNumberOfSubdivisions"
                 property="MaximumNumberOfSubdivisions" type="int"
                 range="0 8"/>
    <Documentation>
The Tessellate filter tessellates cells with nonlinear geometry and/or scalar fields into a simplicial complex with linearly interpolated field values that more closely approximate the original field. This is useful for the quadratic cells supported by VTK. There are several settings that affect the tessellation.
The Output Dimension specifies whether nonlinear cells should have their volumes, surfaces, or edges tessellated. When the Output Dimension is 3, 3-D cells produce tetrahedra, 2-D cells produce triangles, and 1-D cells produce line segments. When the Output Dimension is 2, 3-D cells will have their boundaries tessellated with triangles. When the Output Dimension is 1, then all cells except points produce line segments.
The Max Chord Error setting is the maximum allowed distance between the midpoint of any output edge and the original nonlinear geometry.
The Max Field Error setting is a per-field error, also sampled at midpoints, but comparing the linear and nonlinear field values.
The Max Num Of Subdivisions setting specifies the maximum number of times an edge may be subdivided. Increasing this number allows further refinement but can drastically increase the computational and storage requirements, especially when the Output Dimension is 3.
    </Documentation>
  </Module>
  <Module name="DataSetTriangleFilter"
          menu_name="Tetrahedralize"
          root_name="Tetra"
          module_type="Filter"
          long_help="This filter converts 3-d cells to tetrahedrons and polygons to triangles.  The output is always of type unstructured grid."
          short_help="Convert to tetrahedrons and triangles.">
    <Filter class="vtkDataSetTriangleFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Tetrahedralize filter converts the 3D cells of any type of data set to tetrahedrons and the 2D ones to triangles. This filter always produces unstructured grid output.
    </Documentation>
  </Module>
  <Module name="TriangleFilter"
          menu_name="Triangulate"
          root_name="Tri"
          module_type="Filter"
          long_help="This filter converts polygons and triangle strips to basic triangles."
          short_help="Convert polygonal data to triangles.">
    <Filter class="vtkTriangleFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Triangulate filter decomposes polygonal data into only triangles, points, and lines. It separates triangle strips and polylines into individual triangles and lines, respectively. The output is polygonal data. Some filters that take polygonal data as input require that the data be composed of triangles rather than other polygons, so passing your data through this filter first is useful in such situations. You should use this filter in these cases rather than the Tetrahedralize filter because they produce different output data set types. The filters referenced require polygonal input, and the Tetrahedralize filter produces unstructured grid output.
    </Documentation>
  </Module>
  <Module name="TransformFilter"
          menu_name="Transform"
          root_name="Trans"
          module_type="Filter"
          long_help="This filter applies transformation to the polygons."
          short_help="Transform polygonal data.">
    <Filter class="vtkTransformFilter">
      <Input name="Input"
             class="vtkPointSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectWidget label="Transform Widget"
                  trace_name="Transform Widget"
                  property="Transform">
      <Item label="Box"
            value="BoxTransform">
      <BoxWidget use_label="0"
                 trace_name="Box"
                 input_menu="im1"
                 help="Adjusts the parameters of the box to clip with."/>
      </Item>
    </SelectWidget>
    <Documentation>
The Transform filter allows you to specify the position, size, and orientation of polygonal, unstructured grid, and curvilinear data sets. You can interactively perform these affine transformations on the data by using the box widget, and the parameters can also be controlled manually. See section 7.4 for the details of using the box widget and manually setting its parameters. The output of this filter will have the same data set type as the input.
    </Documentation>
  </Module>
  <Module name="TubeFilter"
          menu_name="Tube"
          root_name="Tuber"
          module_type="Filter"
          long_help="Convert lines into tubes.  Normals are used to avoid cracks between tube segments."
          short_help="Convert lines into tubes.">
    <Filter class="vtkTubeFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ThumbWheel label="Num. sides"
                property="NumberOfSides"
                trace_name="NumberOfSides"
                resolution="1"
                minimum_value="3"
                help="Set the number of sides for the tube"/>
    <LabeledToggle label="Capping"
                   trace_name="Capping"
                   property="Capping"
                   help="Select whether to draw endcaps on the tube"/>
    <ScaleFactorEntry label="Radius"
                      property="Radius"
                      input_menu="im"
                      trace_name="Radius"
                      help="Set the radius of the tube" />
    <SelectionList label="Vary radius"
                   trace_name="VaryRadius"
                   property="VaryRadius"
                   help="Select whether/how to vary the radius of the tube">
      <Item name="Off"
            value="0"/>
      <Item name="By Scalar"
            value="1"/>
      <Item name="By Vector"
            value="2"/>
    </SelectionList>
    <!-- RadiusFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Radius factor"
                 trace_name="RadiusFactor"
                 property="RadiusFactor"
                 type="float"
                 help="Set the maximum tube radius in terms of a multiple of the minimum radius"/>
    <Documentation>
The Tube filter creates tubes around the lines in the input polygonal data set. The output is also polygonal. The Num. sides value determines the number of faces around the circumference of the tube. The Capping toggle specifies whether to close the end of the tube with a polygon. The Radius entry determines the radius of the tube (or the minimum radius if you are varying the radius). From the Vary radius menu, you can select whether the radius of the tube should vary, and if so, whether it should be by scalar or by vector. If the radius is varied by scalar, the tube radius is based on the point-based scalar values. If it is varied by vector, the vector magnitude is used. If you are varying the radius, the value in the Radius factor entry determines the maximum radius by specifying a multiplier of the Radius value.
    </Documentation>
  </Module>
  <Module name="WarpScalar"
          menu_name="Warp (scalar)"
          root_name="WarpS"
          module_type="Filter"
          long_help="This filter moves point coordinates along a vector scaled by a point attribute.  It can be used to produce carpet plots."
          short_help="Warp point scalars into a spatial elevation plot.">
    <Filter class="vtkWarpScalar">
      <Input name="Input"
             class="vtkPointSet">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu property="SelectInputScalars"
               trace_name="Scalars"
               label="Scalars"
               input_menu="im"
               help="Select the input scalars to process."/>
    <!-- ScaleFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Scale factor"
                 property="ScaleFactor"
                 trace_name="ScaleFactor"
                 type="float"
                 help="Displacement is vector times scale."/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Normal"
                 property="Normal"
                 trace_name="Normal"
                 type="float"
                 length="3"
                 help="Warp direction."/>
    <LabeledToggle label="Use normal"
                   trace_name="UseNormal"
                   property="UseNormal"
                   help="Use instance model normals rather than instance normal."/>
    <LabeledToggle label="X-Y plane"
                   trace_name="XYPlane"
                   property="XYPlane"
                   help="Z value is used to warp the surface, scalars to color surface."/>
    <Documentation>
The Warp (scalar) filter translates the points of the input data set along a vector by a distance determined by the specified scalars (selected from the Scalars menu). The Scale factor entry allows you to rescale the scalar values used in warping the data.
The Normal entries specify the direction in which to warp the geometry if the Use normal option is checked. If Use normal and X-Y plane are off, the data set will be warped along its normals array. (If no normals array exists, the Normal value will be used.) If X-Y plane is on, the Z-values in the data set are considered to be scalars, and warping is done along the Z axis. This is useful for creating carpet plots. Any scalars in the data set are copied to the output, so the data can be colored by them.
This filter operates on polygonal, curvilinear, and unstructured grid data sets containing single-component scalar arrays. Because it only changes the positions of the points, the output data set type is the same as that of the input.
    </Documentation>
  </Module>
  <Module name="WarpVector"
          root_name="WarpV"
          menu_name="Warp (vector)"
          button_image="PVVectorDisplacementButton"
          button_help="Warp (displace) the geometry with a given vector field."
          module_type="Filter"
          long_help="This filter displaces point coordinates along a vector attribute.  It is useful for showing mechanical deformation."
          short_help="Warp (displace) the geometry with a given vector field.">
    <Filter class="vtkPVWarpVector">
      <Input name="Input"
             class="vtkPointSet">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu property="SelectInputVectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               help="Select the input vectors to process."/>
    <!-- ScaleFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Scale factor"
                 trace_name="ScaleFactor"
                 property="ScaleFactor"
                 type="float"
                 help="Displacement is vector times scale."/>
    <Documentation>
The Warp (vector) filter translates the points of the input data set using a specified vector array. The vector array chosen specifies a vector per point in the input. Each point is translated along its vector by the value in the Scale factor entry box. This filter operates on polygonal, curvilinear, and unstructured grid data sets. Because this filter only changes the positions of the points, the output data set type is the same as that of the input. This filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="Cut"
          root_name="Cut"
          replace_input="0"
          module_type="Filter"
          button_image="PVCutButton"
          button_help="Cut with an implicit plane or sphere. Cutting typically reduces the dimensionality of the data."
          long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
          short_help="Cut datasets with planes or spheres.">
    <Filter class="vtkCutter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <BoundsDisplay show_hide_frame="1"
                   label="Input Bounds"
                   property="InputBounds"
                   trace_name="Input Bounds"
                   input_menu="im1"/>
    <SelectWidget label="Cut Function"
                  trace_name="Cut Function"
                  property="CutFunction">
      <Item label="Plane"
            value="Plane">
      <ImplicitPlaneWidget trace_name="Plane"
                           use_label="0"
                           input_menu="im1"
                           help="Adjusts the parameters of the plane to cut with."/>
      </Item>
      <Item label="Sphere"
            value="Sphere">
      <SphereWidget trace_name="Sphere"
                    use_label="0"
                    input_menu="im1"
                    help="Adjusts the parameters of the sphere to cut with."/>
      </Item>
      <Item label="Box"
            value="Box">
        <BoxWidget use_label="0"
                   trace_name="Box"
                   input_menu="im1"
                   help="Adjusts the parameters of the box to cut with."/>
      </Item>
    </SelectWidget>
    <CutEntry label="Cut Offset Values"
              trace_name="Cut Values"
              input_menu="im1" property="ContourValues"
              help="List of current offset values. This can be used to create multiple cut planes/spheres with different centers. Each entry represents a new cut with center shifted by the offset value."/>
    <Documentation>
The Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Cut filter takes any type of data set as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data. This filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="Clip"
          root_name="Clip"
          module_type="Filter"
          button_image="PVClipButton"
          button_help="Clip with an implicit plane, sphere or with scalars.Clipping does not reduce the dimensionality of the data set."
          long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
          short_help="Clip with an implicit plane, sphere or with scalars.">
    <Filter class="vtkPVClipDataSet">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <BoundsDisplay show_hide_frame="1"
                   label="Input Bounds"
                   property="InputBounds"
                   trace_name="Input Bounds"
                   input_menu="im1"/>
    <SelectWidget label="Clip Function"
                  trace_name="Clip Function"
                  property="ClipFunction">
      <Item label="Plane"
            value="Plane">
        <ImplicitPlaneWidget use_label="0"
                             trace_name="Plane"
                             input_menu="im1"
                             help="Adjusts the parameters of the plane to clip with."/>
      </Item>
      <Item label="Sphere"
            value="Sphere">
        <SphereWidget use_label="0"
                      trace_name="Sphere"
                      input_menu="im1"
                      help="Adjusts the parameters of the sphere to clip with."/>
      </Item>
      <Item label="Box"
            value="Box">
        <BoxWidget use_label="0"
                   trace_name="Box"
                   input_menu="im1"
                   help="Adjusts the parameters of the box to clip with."/>
      </Item>
      <Item label="Scalars">
        <ContainerWidget trace_name="ScalarClip">
          <Item>
            <ScalarRangeLabel property="Value" 
                              trace_name="ScalarRange" 
                              array_menu="it3.am1"/>
          </Item>
          <Item id="it3">
          <ArrayMenu id="am1" property="SelectInputScalars"
                     trace_name="Scalars"
                     label="Scalars"
                     help="Choose the clipping scalar array."
                     input_menu="im1"/>
          </Item>
          <Item>
            <!-- Value depends on scalar range of input -->
            <VectorEntry label="Clip value"
                         trace_name="Offset"
                         type="float"
                         property="Value"
                         help="Choose the scalar value to clip with"/>
          </Item>
        </ContainerWidget>
      </Item>
    </SelectWidget>
    <LabeledToggle label="Inside Out"
                   trace_name="InsideOut"
                   property="InsideOut"
                   help="Switches which part to keep."/>
    <Documentation>
The Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
    </Documentation>
  </Module>
  <Module name="Threshold"
          root_name="Threshold"
          button_image="PVThresholdButton"
          module_type="Filter"
          button_help="Extract cells that satisfy a threshold criterion."
          long_help="This filter extracts cells that have point or cell scalars in the specified range."
          short_help="Extract cells that satisfy a threshold criterion.">
    <Filter class="vtkThreshold">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               input_name="Input"
               help="Set the input to this filter." />
    <FieldMenu id="fm"
               trace_name="FieldMenu"
               input_menu="im"
               property="SelectInputScalars"
               help="Choose cell or point field to threshold." />
    <ArrayMenu id="am" property="SelectInputScalars"
               trace_name="Scalars"
               label="Scalars"
               field_menu="fm"
               help="Choose the threshold scalar array."/>
    <MinMax trace_name="MinMax"
            array_menu="am"
            property="ThresholdBetween"
            min_label="Lower Threshold"
            max_label="Upper Threshold"
            min_help="Choose the lower value of the threshold"
            max_help="Choose the upper value of the threshold"/>
    <LabeledToggle label="All Scalars"
                   trace_name="AllScalars"
                   property="AllScalars"
                   help="If AllScalars is checked, then a cell is only included if all its points are within the threshold. This is only relevant for point data."/>
    <Documentation>
The Threshold filter extracts the portions of the input data set whose scalars lie within the specified range. This filter operates on either point-centered or cell-centered data. To select between these two options, select either Point Data or Cell Data from the Attribute Mode menu. Once the Attribute Mode has been selected, choose the scalar array from which to threshold the data from the Scalars menu. The Lower Threshold and Upper Threshold sliders determine the range of the scalars to retain in the output. The All Scalars check box only takes effect when the Attribute Mode is set to Point Data. If the All Scalars option is checked, then a cell will only be passed to the output if the scalar values of all of its points lie within the range indicated by the Lower Threshold and Upper Threshold sliders. If unchecked, then a cell will be added to the output if the specified scalar value for any of its points is within the chosen range. This filter operates on any type of data set and produces unstructured grid output. The Threshold filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="Contour"
          root_name="Contour"
          button_image="PVContourButton"
          module_type="Filter"
          replace_input="0"
          button_help="Generate isolines or isosurfaces."
          long_help="Generate isolines or isosurfaces using point scalars."
          short_help="Generate isolines or isosurfaces.">
    <Filter class="vtkContourFilter">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    // Do not change the tracename of the input menu, it is used by vtkPVContour
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               input_name="Input"
               property="Input"
               help="Set the input to this filter." />
    // Do not change the tracename of the array menu, it is used by vtkPVContour
    <ArrayMenu id="am" property="SelectInputScalars"
               label="Scalars"
               trace_name="Scalars"
               input_menu="im"
               help="Choose which scalar array you want to contour."/>
    <ScalarRangeLabel id="srl"
                      property="ContourValues"
                      trace_name="ScalarRangeLabel"
                      array_menu="am"/>
    <ContourEntry label="Contour Values"
                  trace_name="Contour Values"
                  array_menu="am" property="ContourValues"
                  help="List of current contour values." />
    <LabeledToggle label="Compute Normals"
                   property="ComputeNormals"
                   trace_name="Compute Normals"
                   help="Select whether to compute normals" />
    <LabeledToggle label="Compute Gradients"
                   property="ComputeGradients"
                   trace_name="Compute Gradients"
                   help="Select whether to compute gradients"/>
    <LabeledToggle label="Compute Scalars"
                   property="ComputeScalars"
                   trace_name="Compute Scalars"
                   help="Select whether to compute scalars" />
    <Documentation>
The Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Contour filter operates on any type of data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal. This filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="Glyph"
          root_name="Glyph"
          module_type="Filter"
          button_image="PVGlyphButton"
          replace_input="0"
          button_help="Generate a glyph (symbol) at each point of the dataset. These can be colored, scaled and oriented"
          long_help="This filter generates an arrow, cone, line, sphere, or 2D glyph at each point of the input data set.  The glyphs can be oriented and scaled by the input point attributes."
          short_help="Generate a glyph symbol at each point of the input data set.">
    <Filter class="vtkPVGlyphFilter">
      <Input name="Input"
             class="vtkDataSet"/>
      <Input name="Source"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <InputMenu trace_name="Glyph" property="Source"
               id="im2"
               label="Glyph"
               help="Select the glyph source."
               input_name="Source" initialize_with_current="0"
               source_list="GlyphSources"/>
    <OrientScaleWidget trace_name="OrientScale" input_menu="im"
                       scalar_property="SelectInputScalars"
                       vector_property="SelectInputVectors"
                       orient_mode_property="SetOrient"
                       scale_mode_property="SetScaleMode"
                       scale_factor_property="SetScaleFactor"/>
    <ThumbWheel label="Max. Number of Glyphs"
                trace_name="Max Glyphs"
                property="MaximumNumberOfPoints"
                resolution="1"
                minimum_value="0"
                help="Set the maximum number of points to glyph"/>
    <LabeledToggle label="Mask Points"
                   trace_name="MaskPoints"
                   property="UseMaskPoints"
                   help="Create no more than specified maximum number of glyphs" />
    <LabeledToggle label="Random Masking"
                   trace_name="RandomMask"
                   property="RandomMode"
                   help="Choose points at random to mask" />
    <Documentation>
The Glyph filter generates a glyph (i.e., an arrow, cone, line, sphere, or 2D glyph) at each point in the input data set. The glyphs can be oriented and scaled by the input point-centered scalars and vectors.
From the Glyph menu, select which symbol should be drawn at each input point. The available choices are Arrow, Cone, Line, Sphere, and Glyph2D. To change the parameters of any of the glyphs (including which 2D glyph is drawn), choose the appropriate glyph from the Glyphs submenu of the Select menu. Change the desired parameter(s) and click Accept. To return to the Glyph interface, select this filter from the Selection / Navigation Window or from the Select menu.
The Orient / Scale section of the interface determines how the point-centered scalars and vectors contribute to the orientation and scale of the widgets. The Orient Mode menu determines whether the glyphs are drawn in their original orientation (Off) or in an orientation determined by a vector array (Vector). If the input does not contain point-centered vectors, the Vector option in the Orient Mode menu will not be available.
The Scale Mode menu determines how the scale of the glyphs will be calculated. The options are to scale by the selected scalar array (Scalar), to scale by the magnitudes of the selected vector array (Vector Magnitude), to scale by each component of the selected vector array (Vector Components), or to draw the all the glyphs at the same scale (Data Scaling Off). If the input contains no point-centered scalar arrays, the Scalar option will be disabled. If it has no point-centered vector arrays, the Vector Magnitude and Vector Components entries will be unavailable. The value of the Scale Factor entry box is a multiplier that contributes to the final size of the glyphs.
The Scalars and Vectors menus list the point-centered scalar (single-component) and vector (three-component) arrays in the input data set. These menus are enabled and disabled depending on the current Orient and Scale Mode selections.
The Glyph Parameters tab also contains controls for masking the input points before glyphing. (This is a simplified version of the Mask Points filter interface.) To enable point masking, turn on the Mask Points option. When this is selected, the Max. Number of Glyphs thumbwheel sets an upper limit on the number of glyphs to display. If the Random Masking option is on, the input points to glyph will be randomly selected; otherwise every second point will be glyphed, starting from the first point id.
The Glyph filter operates on any type of data set. Its output is polygonal. This filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="Pick"
          class="vtkPVPick"
          root_name="Pick"
          button_image="PVPickButton"
          button_help="Pick a cell and display its attributes. Use the 'p' key to pick the cell under the cursor."
          module_type="Filter"
          long_help="Find the cell or point closest to the input point."
          short_help="Pick cells or points.">
    <Filter class="vtkPickFilter">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple">
      </Input>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectionList property="PickCell"
                   label="Pick Type"
                   trace_name="PickType"
                   help="Select whether to pick cells or points.">
      <Item name="Point" value="0"/>
      <Item name="Cell" value="1"/>
    </SelectionList>
    <SelectWidget label="Pick Method"
                  trace_name="PickMethod"
                  property="UseIdToPick">
      <Item label="World Point" value="0">
        <PointWidget trace_name="Point" variable="WorldPoint"
                     help="Pick cell or point closest to this world point.  The 'p' key can be used to select a point under the cursor."/>
      </Item>
      <Item label="ID" value="1">
        <VectorEntry  label="Id" property="Id" trace_name="Id"
                      type="int" length="1"
                      help="The Id of the point or cell to pick." />
      </Item>
    </SelectWidget>
    <Documentation>
The Pick filter displays the underlying data nearest to a user-selected point. A point widget, with its usual controls in the display area and on the Parameters tab, is provided for choosing this point. (See section 7.4 for information about using the point widget.) Pressing the "P" key positions the point widget at the point on the data set under the current cursor position. If you select Point from the Pick Type menu, the output of the filter will be the nearest point to the point widget. If you select Cell, the output of the filter is the cell which is closest to the selected point. All the output point-centered attributes, cell-centered attributes, and original ids are displayed on the Parameters tab. Also, the selected cell will be outlined in red in the display area, and the reference ids of the points within that cell will be labeled.
The Pick filter operates on any type of data and produces unstructured grid output.
    </Documentation>
  </Module>
  <Module name="Probe"
          class="vtkPVProbe"
          root_name="Probe"
          button_image="PVProbeButton"
          button_help="Sample data values at a point or along a line"
          module_type="Filter"
          long_help="Sample data attributes at a point or along a line.  Probed lines will be displayed in a graph of the attributes."
          short_help="Sample data values at a point or along a line.">
    <Filter class="vtkPProbeFilter">
      <Input name="Source"
             class="vtkDataSet">
        <GroupRequirement quantity="Single"/>
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
      <Input name="Source"
             class="vtkMultiGroupDataSet">
        <GroupRequirement quantity="Single"/>
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Source" property="Source"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Source"/>
    <SelectWidget label="Probe object"
                  trace_name="Probe object"
                  property="Input">
      <Item label="Point"
            value="Output">
      <PointSourceWidget trace_name="Point"
                         default_radius="0" input_menu="im"
                         default_number_of_points="1"
                         show_entries="0"/>
      </Item>
        <Item label="Line"
              value="Output">
        <LineSourceWidget trace_name="Line" input_menu="im"/>
      </Item>
    </SelectWidget>
    <Documentation>
The Probe filter samples the data set attributes of the current data set at a point or along a line. Selecting either Point or Line from the menu button in the Probe object portion of the interface displays the appropriate 3D widget and its associated user interface controls. See section 7.4 for more information about using 3D widgets.
If you are probing with a point, the values of the point-centered variables at the selected point will be listed on the Parameters tab for this filter. If you are probing with a line, the values of the point-centered variables along that line will be displayed in a 2D graph in the display area if Show XY-Plot is selected.
Probing with a point is different from using the Pick filter at a point because the Pick filter displays the values for the input point closest to the selected point. Instead the Probe filter uses interpolation to determine the value at the selected point, whether or not it lies at an input point.
The Probe filter operates on any type of data and produces polygonal output (a point or a line).
    </Documentation>
  </Module>
  <Module name="StreamTracer"
          root_name="Stream"
          menu_name="Stream Tracer"
          module_type="Filter"
          replace_input="0"
          button_image="PVStreamTracerButton"
          button_help="Generate streamtraces from a collection of seed points."
          long_help="Integrate streamlines in a vector field."
          short_help="Integrate streamlines in a vector field.">
    <Filter class="vtkDistributedStreamTracer">
      <Input name="Input"
             class="vtkDataSet"
             quantity="Multiple">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu property="SelectInputVectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               help="Select the input vectors to use."/>
    <SelectWidget trace_name="Seed"
                  label="Seed"
                  property="Source">
      <Item label="Point Cloud"
            value="Output">
        <PointSourceWidget trace_name="Point"
                           radius_scale_factor=".1"
                           input_menu="im"
                           default_number_of_points="100"
                           show_entries="1"/>
      </Item>
      <Item label="Line"
            value="Output">
        <LineSourceWidget trace_name="Line" input_menu="im"/>
      </Item>
    </SelectWidget>
    <ContainerWidget pack_direction="left" trace_name="MaxProp">
      <Item>
        <SelectionList property="MaximumPropagationUnit"
                       trace_name="MaximumPropagationUnit"
                       label="Max. Propagation"
                       option_width="15"
                       help="Maximum propagation">
          <Item name="Time"
                value="0"/>
          <Item name="Length"
                value="1"/>
        </SelectionList>
      </Item>
      <Item>
        <ScaleFactorEntry label=""
                          property="MaximumPropagation"
                          trace_name="MaxPropLen"
                          input_menu="im"
                          help="Maximum propagation" />
      </Item>
    </ContainerWidget>
    <ContainerWidget pack_direction="left" trace_name="InitLen">
      <Item>
        <SelectionList trace_name="InitialIntegrationStepUnit"
                       property="InitialIntegrationStepUnit"
                       label="Init. Step Len."
                       option_width="15"
                       help="Initial step length">
          <Item name="Time"
                value="0"/>
          <Item name="Length"
                value="1"/>
          <Item name="Cell Length"
                value="2"/>
        </SelectionList>
      </Item>
      <Item>
        <VectorEntry label=""
                     property="InitialIntegrationStep"
                     type="float"
                     trace_name="InitLen"
                     help="Initial step length"/>
      </Item>
    </ContainerWidget>
    <SelectionList trace_name="IntegrationDirection"
                   property="IntegrationDirection"
                   label="Integration Direction"
                   option_width="15">
      <Item name="FORWARD"
            value="0"/>
      <Item name="BACKWARD"
            value="1"/>
      <Item name="BOTH"
            value="2"/>
    </SelectionList>
    <SelectWidget label="Integrator Type"
                  property="IntegratorType"
                  trace_name="IntegrationType">
      <Item label="Runge-Kutta 2" value="0">
        <DummyWidget trace_name="Dummy1"/>
      </Item>
      <Item label="Runge-Kutta 4" value="1">
        <DummyWidget trace_name="Dummy2"/>
      </Item>
      <Item label="Runge-Kutta 4-5" value="2">
        <ContainerWidget trace_name="MinLen">
      <Item>
        <ContainerWidget pack_direction="left" trace_name="MinLen">
          <Item>
            <SelectionList property="MinimumIntegrationStepUnit"
                           trace_name="MinimumIntegrationStepUnit"
                           label="Min. Step Len."
                           option_width="15"
                           help="Minimum step length used in the integation">
              <Item name="Time"
                    value="0"/>
              <Item name="Length"
                    value="1"/>
              <Item name="Cell Length"
                    value="2"/>
            </SelectionList>
          </Item>
          <Item>
            <VectorEntry label=""
                         property="MinimumIntegrationStep"
                         type="float"
                         trace_name="MinLen"
                         help="Minimum step length  used in the integation"/>
          </Item>
        </ContainerWidget>
      </Item>
      <Item>
        <ContainerWidget pack_direction="left" trace_name="MaxLen">
          <Item>
            <SelectionList property="MaximumIntegrationStepUnit"
                           trace_name="MaximumIntegrationStepUnit"
                           label="Max. Step Len."
                           option_width="15"
                           help="Maximum step length used in the integration">
              <Item name="Time"
                    value="0"/>
              <Item name="Length"
                    value="1"/>
              <Item name="Cell Length"
                    value="2"/>
            </SelectionList>
          </Item>
          <Item>
            <VectorEntry label=""
                         property="MaximumIntegrationStep"
                         type="float"
                         trace_name="MaxLen"
                         help="Maximum step length used in the integration"/>
          </Item>
        </ContainerWidget>
      </Item>
      <Item>
      <VectorEntry label="Maximum Error"
                   trace_name="MaximumError"
                   property="MaximumError"
                   type="float"
                   help="Maximum error allowed in the integration"/>
      </Item>
      </ContainerWidget>
      </Item>
    </SelectWidget>
    <VectorEntry label="Max. Steps"
                 trace_name="MaximumNumberOfSteps"
                 property="MaximumNumberOfSteps"
                 type="int"
                 help="Maximum number of steps."/>
    <VectorEntry label="Term. Speed"
                 trace_name="TerminalSpeed"
                 property="TerminalSpeed"
                 type="float"
                 help="Terminal speed. The integration will be stopped if the speed (absolute value) is smaller than this threshold"/>
    <Documentation>
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="ExtractGrid"
          root_name="ExtractGrid"
          menu_name="Extract Grid"
          module_type="Filter"
          button_image="PVExtractGridButton"
          replace_input="0"
          button_help="Extract a subgrid or subsample."
          long_help="Extract a subgrid from a structured grid with the option of setting subsample strides."
          short_help="Extract a subgrid or subsample.">
    <Filter class="vtkPVExtractVOI">
      <Input name="Input"
             class="vtkStructuredData"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ExtentEntry label="VOI"
                 trace_name="VOI"
                 property="VOI"
                 input_menu="im"
                 help="Set the min/max values of the volume of interest (VOI). The output will have the (I,J,K) extent specified here."/>
    <ContainerWidget pack_direction="left" trace_name="SampleRate">
      <Item>
        <ThumbWheel label="Sample Rate"
                    property="SampleRateI"
                    trace_name="SampleRateI"
                    resolution="1"
                    minimum_value="1"
                    help="Set the sampling rate for each dimension."/>
      </Item>
      <Item>
        <ThumbWheel label=""
                    property="SampleRateJ"
                    trace_name="SampleRateJ"
                    resolution="1"
                    minimum_value="1"
                    help="Set the sampling rate for each dimension."/>
      </Item>
      <Item>
        <ThumbWheel label=""
                    property="SampleRateK"
                    trace_name="SampleRateK"
                    resolution="1"
                    minimum_value="1"
                    help="Set the sampling rate for each dimension."/>
      </Item>
    </ContainerWidget>
    <LabeledToggle label="Include boundary"
                   property="IncludeBoundary"
                   trace_name="IncludeBoundary"
                   help="Select whether to always include the boundary of the grid in the output"/>
    <Documentation>
The Extract Grid filter returns a subgrid of a structured input data set (uniform rectilinear, curvilinear, or nonuniform rectilinear). The VOI section of the interface provides six sliders for specifying the extents of the desired output along each of the I, J, and K axes. The Sample Rate thumb wheels control whether to subsample the input grid in each dimension. Values greater than 1 result in subsampling. For example, if the Sample Rate along the I axis is 2, then every other input point will be passed to the output. If the Sample Rate in any dimension is greater than 1, then selecting the Include boundary option will pass the values on the boundary of the data set to the output even if the boundary extent is not an even multiple of the sample rate. The output data set type of this filter is the same as the input type. This filter is available on the Toolbar.
    </Documentation>
  </Module>

 <Module name="GenericClip"
    root_name="GenericClip"
    module_type="Filter"
    button_help="Clip with an implicit plane, sphere or with scalars.Clipping does not reduce the dimensionality of the data set."
    long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
    short_help="Clip with an implicit plane, sphere or with scalars.">
    <Filter class="vtkGenericClip">
      <Input name="Input"
             class="vtkGenericDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <BoundsDisplay show_hide_frame="1"
                   label="Input Bounds"
                   property="InputBounds"
                   trace_name="Input Bounds"
                   input_menu="im1"/>
    <SelectWidget label="Clip Function"
                  trace_name="Clip Function"
                  property="ClipFunction">
      <Item label="Plane"
            value="Plane">
        <ImplicitPlaneWidget use_label="0"
                             trace_name="Plane"
                             input_menu="im1"
                             help="Adjusts the parameters of the plane to clip with."/>
      </Item>
      <Item label="Sphere"
            value="Sphere">
        <SphereWidget use_label="0"
                      trace_name="Sphere"
                      input_menu="im1"
                      help="Adjusts the parameters of the sphere to clip with."/>
      </Item>
      <Item label="Box"
            value="Box">
        <BoxWidget use_label="0"
                   trace_name="Box"
                   input_menu="im1"
                   help="Adjusts the parameters of the box to clip with."/>
      </Item>
      <Item label="Scalars">
        <ContainerWidget trace_name="ScalarClip">
          <Item>
            <ScalarRangeLabel property="Value" 
                              trace_name="ScalarRange" 
                              array_menu="it3.am1"/>
          </Item>
          <Item id="it3">
          <ArrayMenu id="am1" property="SelectInputScalars"
                     trace_name="Scalars"
                     label="Scalars"
                     help="Choose the clipping scalar array."
                     input_menu="im1"/>
          </Item>
          <Item>
            <!-- Value depends on scalar range of input -->
            <VectorEntry label="Clip value"
                         trace_name="Offset"
                         type="float"
                         property="Value"
                         help="Choose the scalar value to clip with"/>
          </Item>
        </ContainerWidget>
      </Item>
    </SelectWidget>
    <LabeledToggle label="Inside Out"
                   trace_name="InsideOut"
                   property="InsideOut"
                   help="Switches which part to keep."/>
    <Documentation>
The Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
    </Documentation>
  </Module>


  <Module name="GenericContour"
          root_name="GenericContour"
          module_type="Filter"
          replace_input="0"
          button_help="Generate isolines or isosurfaces."
          long_help="Generate isolines or isosurfaces using point scalars."
          short_help="Generate isolines or isosurfaces.">

    <Filter class="vtkGenericContourFilter">
      <Input name="Input"
             class="vtkGenericDataSet">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>

    // Do not change the tracename of the input menu, it is used by vtkPVContour
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               input_name="Input"
               property="Input"
               help="Set the input to this filter." />
    // Do not change the tracename of the array menu, it is used by vtkPVContour
    <ArrayMenu id="am" property="SelectInputScalars"
               label="Scalars"
               trace_name="Scalars"
               input_menu="im"
               help="Choose which scalar array you want to contour."/>
    <ScalarRangeLabel id="srl"
                      property="ContourValues"
                      trace_name="ScalarRangeLabel"
                      array_menu="am"/>
    <ContourEntry label="Contour Values"
                  trace_name="Contour Values"
                  array_menu="am" property="ContourValues"
                  help="List of current contour values." />
    <LabeledToggle label="Compute Normals"
                   property="ComputeNormals"
                   trace_name="Compute Normals"
                   help="Select whether to compute normals" />
    <LabeledToggle label="Compute Gradients"
                   property="ComputeGradients"
                   trace_name="Compute Gradients"
                   help="Select whether to compute gradients"/>
    <LabeledToggle label="Compute Scalars"
                   property="ComputeScalars"
                   trace_name="Compute Scalars"
                   help="Select whether to compute scalars" />
    <Documentation>
The Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Contour filter operates on any type of data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal. This filter is available on the Toolbar.
    </Documentation>
  </Module>

  <Module name="GenericCut"
          root_name="GenericCut"
          replace_input="0"
          module_type="Filter"
          button_help="Cut with an implicit plane or sphere. Cutting typically reduces the dimensionality of the data."
          long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
          short_help="Cut datasets with planes or spheres.">
    <Filter class="vtkGenericCutter">
      <Input name="Input"
             class="vtkGenericDataSet"/>
    </Filter>

    <InputMenu trace_name="Input" property="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <BoundsDisplay show_hide_frame="1"
                   label="Input Bounds"
                   property="InputBounds"
                   trace_name="Input Bounds"
                   input_menu="im1"/>
    <SelectWidget label="Cut Function"
                  trace_name="Cut Function"
                  property="CutFunction">
      <Item label="Plane"
            value="Plane">
      <ImplicitPlaneWidget trace_name="Plane"
                           use_label="0"
                           input_menu="im1"
                           help="Adjusts the parameters of the plane to cut with."/>
      </Item>
      <Item label="Sphere"
            value="Sphere">
      <SphereWidget trace_name="Sphere"
                    use_label="0"
                    input_menu="im1"
                    help="Adjusts the parameters of the sphere to cut with."/>
      </Item>
    </SelectWidget>
    <CutEntry label="Cut Offset Values"
              trace_name="Cut Values"
              input_menu="im1" property="ContourValues"
              help="List of current offset values. This can be used to create multiple cut planes/spheres with different centers. Each entry represents a new cut with center shifted by the offset value."/>
    <Documentation>
The Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Cut filter takes any type of data set as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data. This filter is available on the Toolbar.
    </Documentation>
  </Module>

 <Module name="GenericGeometryFilter" menu_name="GenericGeometryFilter" root_name="PolyData"
         module_type="Filter"
         long_help="Extract geometry from a higher-order dataset"
         short_help="Extract geometry from a higher-order dataset">
 
 <Filter class="vtkGenericGeometryFilter">
      <Input name="Input"
             class="vtkGenericDataSet"/>
    </Filter>
  <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
  <Documentation>
Extract geometry from a higher-order dataset.
  </Documentation>
 </Module>

 <Module name="GenericOutlineFilter"
          menu_name="Generic Outline"
          root_name="Outline"
          module_type="Filter"
          replace_input="0"
          long_help="This filter generates a bounding box representation of the input."
          short_help="Generates a bounding box.">
    <Filter class="vtkGenericOutlineFilter">
      <Input name="Input"
             class="vtkGenericDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input" property="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on any type of data set and produces polygonal output.
    </Documentation>
  </Module>

<Module name="GenericStreamTracer"
          root_name="Stream"
          menu_name="Generic Stream Tracer"
          module_type="Filter"
          replace_input="0"
          button_help="Generate streamtraces from a collection of seed points."
          long_help="Integrate streamlines in a vector field."
          short_help="Integrate streamlines in a vector field.">
    <Filter class="vtkGenericStreamTracer">
      <Input name="Input"
             class="vtkGenericDataSet"
             quantity="Multiple">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu property="SelectInputVectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               help="Select the input vectors to use."/>
    <SelectWidget trace_name="Seed"
                  label="Seed"
                  property="Source">
      <Item label="Point Cloud"
            value="Output">
        <PointSourceWidget trace_name="Point"
                           radius_scale_factor=".1"
                           input_menu="im"
                           default_number_of_points="100"
                           show_entries="1"/>
      </Item>
      <Item label="Line"
            value="Output">
        <LineSourceWidget trace_name="Line" input_menu="im"/>
      </Item>
    </SelectWidget>
    <ContainerWidget pack_direction="left" trace_name="MaxProp">
      <Item>
        <SelectionList property="MaximumPropagationUnit"
                       trace_name="MaximumPropagationUnit"
                       label="Max. Propagation"
                       option_width="15"
                       help="Maximum propagation">
          <Item name="Time"
                value="0"/>
          <Item name="Length"
                value="1"/>
        </SelectionList>
      </Item>
      <Item>
        <ScaleFactorEntry label=""
                          property="MaximumPropagation"
                          trace_name="MaxPropLen"
                          input_menu="im"
                          help="Maximum propagation" />
      </Item>
    </ContainerWidget>
    <ContainerWidget pack_direction="left" trace_name="InitLen">
      <Item>
        <SelectionList trace_name="InitialIntegrationStepUnit"
                       property="InitialIntegrationStepUnit"
                       label="Init. Step Len."
                       option_width="15"
                       help="Initial step length">
          <Item name="Time"
                value="0"/>
          <Item name="Length"
                value="1"/>
          <Item name="Cell Length"
                value="2"/>
        </SelectionList>
      </Item>
      <Item>
        <VectorEntry label=""
                     property="InitialIntegrationStep"
                     type="float"
                     trace_name="InitLen"
                     help="Initial step length"/>
      </Item>
    </ContainerWidget>
    <SelectionList trace_name="IntegrationDirection"
                   property="IntegrationDirection"
                   label="Integration Direction"
                   option_width="15">
      <Item name="FORWARD"
            value="0"/>
      <Item name="BACKWARD"
            value="1"/>
      <Item name="BOTH"
            value="2"/>
    </SelectionList>
    <SelectWidget label="Integrator Type"
                  property="IntegratorType"
                  trace_name="IntegrationType">
      <Item label="Runge-Kutta 2" value="0">
        <DummyWidget trace_name="Dummy1"/>
      </Item>
      <Item label="Runge-Kutta 4" value="1">
        <DummyWidget trace_name="Dummy2"/>
      </Item>
      <Item label="Runge-Kutta 4-5" value="2">
        <ContainerWidget trace_name="MinLen">
      <Item>
        <ContainerWidget pack_direction="left" trace_name="MinLen">
          <Item>
            <SelectionList property="MinimumIntegrationStepUnit"
                           trace_name="MinimumIntegrationStepUnit"
                           label="Min. Step Len."
                           option_width="15"
                           help="Minimum step length used in the integation">
              <Item name="Time"
                    value="0"/>
              <Item name="Length"
                    value="1"/>
              <Item name="Cell Length"
                    value="2"/>
            </SelectionList>
          </Item>
          <Item>
            <VectorEntry label=""
                         property="MinimumIntegrationStep"
                         type="float"
                         trace_name="MinLen"
                         help="Minimum step length  used in the integation"/>
          </Item>
        </ContainerWidget>
      </Item>
      <Item>
        <ContainerWidget pack_direction="left" trace_name="MaxLen">
          <Item>
            <SelectionList property="MaximumIntegrationStepUnit"
                           trace_name="MaximumIntegrationStepUnit"
                           label="Max. Step Len."
                           option_width="15"
                           help="Maximum step length used in the integration">
              <Item name="Time"
                    value="0"/>
              <Item name="Length"
                    value="1"/>
              <Item name="Cell Length"
                    value="2"/>
            </SelectionList>
          </Item>
          <Item>
            <VectorEntry label=""
                         property="MaximumIntegrationStep"
                         type="float"
                         trace_name="MaxLen"
                         help="Maximum step length used in the integration"/>
          </Item>
        </ContainerWidget>
      </Item>
      <Item>
      <VectorEntry label="Maximum Error"
                   trace_name="MaximumError"
                   property="MaximumError"
                   type="float"
                   help="Maximum error allowed in the integration"/>
      </Item>
      </ContainerWidget>
      </Item>
    </SelectWidget>
    <VectorEntry label="Max. Steps"
                 trace_name="MaximumNumberOfSteps"
                 property="MaximumNumberOfSteps"
                 type="int"
                 help="Maximum number of steps."/>
    <VectorEntry label="Term. Speed"
                 trace_name="TerminalSpeed"
                 property="TerminalSpeed"
                 type="float"
                 help="Terminal speed. The integration will be stopped if the speed (absolute value) is smaller than this threshold"/>
    <Documentation>
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter is available on the Toolbar.
    </Documentation>
  </Module>

<Module name="Tessellator" menu_name="Tessellator" root_name="UnstructuredGrid"
         module_type="Filter"
         long_help="Tessellate a higher-order dataset"
         short_help="Tessellate a higher-order dataset">
 
 <Filter class="vtkGenericDataSetTessellator">
      <Input name="Input"
             class="vtkGenericDataSet"/>
    </Filter>
   <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
  <Documentation>
Tessellate a higher-order dataset.
  </Documentation>
 </Module>

  <Module name="GroupDataSets"
          menu_name="Group Datasets"
          root_name="GroupDataSets"
          module_type="Filter"
          replace_input="1"
          long_help="Group data sets."
          short_help="Group multiple inputs into one collection."
          button_image="PVGroupButton"
          button_help="Group multiple modules into one."
          button_visibility="0">
    <Filter class="vtkMultiGroupDataGroupFilter">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple"/>
    </Filter>
    <GroupInputsWidget trace_name="inputs" property="Input"
                       help="Choose inputs to group."/>
    <Documentation>
Groups multiple datasets to create a multigroup dataset
    </Documentation>
  </Module>

  <Module name="GroupIdScalars"
          menu_name="Level Scalars"
          root_name="LScalars"
          module_type="Filter"
          long_help="This filter uses colors to show levels of a hiearchical dataset."
          short_help="Generate point scalars from level.">
    <Filter class="vtkMultiGroupDataGroupIdScalars">
      <Input name="Input"
             class="vtkMultiGroupDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
This filter uses colors to show levels of a hiearchical dataset.    </Documentation>
  </Module>

  <Module name="ExtractLevel"
          menu_name="Extract Group"
          root_name="ExtGroup"
          module_type="Filter"
          long_help="This filter extracts a range of groups from a multigroup dataset."
          short_help="Extract level.">
    <Filter class="vtkMultiGroupDataExtractGroup">
      <Input name="Input"
             class="vtkMultiGroupDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>

    <MinMax trace_name="MinMax"
            property="GroupRange"
            min_label="Min Group"
            max_label="Max Group"
            min_help="Choose the group range to extract"
            max_help="Choose the group range to extract"/>

    <Documentation>
This filter extracts a range of groups from a multigroup dataset    
    </Documentation>
  </Module>

  <Module name="ExtractDataSets"
          menu_name="Extract Datasets"
          root_name="ExtDS"
          module_type="Filter"
          long_help="This filter extracts a list of datasets from multigroup datasets."
          short_help="Extract datasets.">
    <Filter class="vtkMultiGroupDataExtractDataSets">
      <Input name="Input"
             class="vtkMultiGroupDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ExtractDataSetsWidget trace_name="datasets"
                           property="SelectedDataSets"
                           help="Choose the datasets to extract."/>

    <Documentation>
This filter extracts a list of datasets from multigroup datasets.
    </Documentation>
  </Module>

 <Module name="AttributeEditor"
          root_name="AttributeEditor"
          class="vtkPVAttributeEditor"
          module_type="Filter"
          button_image="PVAttributeEditor"
          button_help="Select with a point or box widget the region to edit."
          button_visibility="0"
          long_help="Select with a point or box widget the region to edit.  This output data type of this filter is always an unstructured grid."
          short_help="Select with a point or box widget the region to edit.">
    <Filter class="vtkAttributeEditor">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple"/>
    </Filter>
    <InputMenu trace_name="Input" property="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <InputMenu trace_name="Source" property="Source"
               id="im2"
               label="Source"
               help="Set the source dataset to this filter."
               input_name="Input"/>
    <ArrayMenu id="am" property="SelectInputScalars"
               trace_name="Scalars"
               label="Scalars"
               input_menu="im1"
               help="Choose the scalar array."/>
    <SelectWidget label="Pick Method"
                  trace_name="PickFunction"
                  property="PickFunction">
      <Item label="'e'dit within a box"
            value="Box">
        <PickBoxWidget use_label="0"
                   trace_name="Box"
                   input_menu="im1"
                   help="Adjusts the parameters of the box to clip with."/>
      </Item>
      <Item label="'e'dit within a draggable sphere"
            value="Sphere">
        <PickSphereWidget use_label="0"
                   trace_name="Sphere"
                   input_menu="im1"
                   help="Adjusts the parameters of the box to clip with."/>
      </Item>
      <Item label="'e'dit at a point" value="Point">
        <PointWidget trace_name="Point" variable="WorldPoint" input_menu="im1"
                     help="Pick the node closest to this world point. The 'p' key can be used to select a node under the cursor."/>
      </Item>
    </SelectWidget>

    <VectorEntry label="Attribute Value"
                        trace_name="AttributeValue"
                        type="float"
                        property="Value"
                        help="Choose the scalar value to select with"/>
    <Documentation>
The Attribute Editor filter selects a portion of the input data set using a box. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function.  The filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
    </Documentation>
  </Module>
</ModuleInterfaces>
