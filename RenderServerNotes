ParaView render server modifications:

There are two types of situations that the new render server will address:

1) Data on a super computer (SGI, IBM, etc) and Rendering on a Linux cluster
   with hardware graphics support.  This problem is known as the "M" to "N"
   geometry load redistribution problem.  It addresses the common case where
   there is a signinficante mismatch in the size of large parallel computing
   resources and the often smaller parallel hardward-accelerated rendering
   resources.  The larger number of processors on the compute servers are
   called M, and the smaller number of rendering processors are call N.

2) Both data and rendering processing occur on a super computer that has
   rendering support.  A certain number of processes will be dedicated to
   each task.  In this case, it is planned that the data server and the
   rendering would all be in the same MPI group.  In this case, we expect
   that we will be able to use the LANL prototype MxN polygon load
   redistribution code.



CASE 1 - data on super computer, rendering on linux cluster

This will be implemented in several stages.

Stage 1:  Create a renderServer process that has a socket connection
from P0 of the ServerManager to P0 of the RenderServer.
The ServerManager (for the time being this will be the current paraview
client) will have a socket connect to P0 on a Data server, and P0 on a Render
server.  It will look something like this:

ServerManger (current paraview client)
  |                                  |
  | socket                           | socket
  |                                  |
 (P0 P1 P2 ... PM)                   (P0 P1 ... PN)
 (Data Server)                       (Render Server)


The following steps will be taken to implement the render server:

      1. Modify paraview so that it can create a RenderServer process.  The
modified paraview will have the following command line options:

           --client-render-server : This will start a client that will try to
           connect to a render server and a data server.  A default port of
           22222 will be used for the render server, and the current default
           port of 11111 will be used for the data server.


           --client : This will start a client that connects to the
           current data server.

           --render-server : This will start the render server, --port will
             be used if present or port 22222 will be used by default.

           paraView --server : This will start a server that can be either a
           data server only server or the current data and rendering server
           that is availiable in paraView now.  How this server is used 
           will depend on the client that connects to it.

           Other command line options:
           
           Server host specifications:

           --host : specify the server host to connect to.  This can be a name
           or an ip address.

           --render-host: specify the render server host
           
           If no host is specified, the localhost will be the default.

           --port : this is the port for connections of the non-render server.  The
           default port is 11111.

           --render-port : this is the port for the render server.  The default
           port is 22222.   When multiple ports are required for the render and data
           servers this will be the base port number and additional ports will follow
           sequentally.
           
           If no server is found, a dialog box will pop up and ask for the name of
           the required servers.

      2. Extend the ProcessModule to send data to the RenderServer with a
      method SendStreamToRenderServer using the new clientserver streams.



Stage 2:

      1. Connect processes on data server to the render server. 
      
      Once the render server is working via the socket connect from P0 of the
      data server and P0 of the render server, the next step will be to
      create socket connections directly from the data server to the render
      server.  For this step P0 .. PN (out of M) of the data server will be
      connected to P0 ... PN (of N) of the render server.   

      The connections will be done with an instance of vtkSocketCommunicator
      for each connection.  However, this will be encapsulated in a new
      vtkCommunicator sub class vtkCompositSocketCommunicator that has an
      array of vtkSocketCommunicator classes in it.  The
      vtkCompositSocketCommunicator will only allow P0 to talk to P0, and P1
      to talk to P1, and not provide a general any P0-N can talk to any other
      P0-N.  

      The vtkCompositSocketCommunicator class will take advantage of the
      existing connection between the render server, the data server, and the
      server manager. Since the server manager will be connected to P0 on
      both the render server and the data server, random ports can be used
      for the connection ports.  The data server will be told to create ports,
      and it will return a vector of pairs of <ip,port>.   The render server will
      then be passed the vector of pairs and connect to each ip port pair.
      Creating the following:

      P0 P1 ... PN ... PM
      |  |      |
      P0 P1 ... PN

 
      2. Change vtkPartDisplay.cxx to create the right objects on the correct servers.
      Basically, this will be an extension of what already exists in
      ParaView.  For a simple case of a Cone display, the pipelines look like this:

         Server:
         Cone -> GeometryFilter -> CollectFilter -> Suppressor -> Mapper -> Actor

         Client:
                                   CollectFilter -> Suppressor -> Mapper -> Actor


      In the new RenderServer version of ParaView it will look something like this:

      DataServer:
         Cone -> GeometryFilter -> CollectFilter -> Suppressor   (N of these)

      RenderServer:
         CollectFilter -> Suppressor -> Mapper -> Actor  (M of these)

       Update will be broadcast to all servers (client, render, data) at the same
       time.

      3. Create a filter that will do the M to N data distribution.  This
      will be based on vtkDuplicatePolydata and will use the MPI call like
      AllGather.  The first implementation will be a brute force division of
      the M to N.  All data will be collected to the server manager and then
      distributed among the renderserver processes.


Stage 3:
     Implement case 2.
