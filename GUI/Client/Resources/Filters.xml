<ModuleInterfaces>
  <Module name="Balance"
          root_name="Balance" module_type="Filter"
          multiprocess_support="multiple_processes"
          long_help="Balance data among available processes."
          short_help="Load balance filter.">
    <Filter class="vtkBalancedRedistributePolyData">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Balance the number of cells on all processes."
               input_name="Input"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="AllToN"
          root_name="AllToN" module_type="Filter" menu_name="All to N"
          multiprocess_support="multiple_processes"
          long_help="Redistribute data to a subset of available processes."
          short_help="Repartition data filter.">
    <Filter class="vtkAllToNRedistributePolyData">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Redistribute polydata to a subset of processes."
               input_name="Input"/>
  <!-- dependent on number of processes being used -->
    <VectorEntry trace_name="NumberOfProcesses"
                 variable="NumberOfProcesses"
                 type="int"
                 default_value="1"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="AppendAttributes"
          menu_name="Append Attributes"
          root_name="AppendAttr"
          module_type="Filter"
          long_help="Copies geometry from first input.  Puts all of the arrays into the output."
          short_help="Puts all input arrays into the single output.">
    <Filter class="vtkMergeArrays">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <Documentation>
The Append Attributes filter takes multiple input datasets with the same geometry and merges their point and cell attributes to produce a single output containing all the point and cell attributes of the inputs. Any inputs without the same number of points and cells as the first input are ignored. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
    </Documentation>
  </Module>
  <Module name="AppendPolyData"
          menu_name="Append Geometry"
          root_name="AppendGeo"
          module_type="Filter"
          long_help="Takes an input of multiple poly data parts and output has only one part."
          short_help="Append multiple parts into one.">
    <Filter class="vtkAppendPolyData">
      <Input name="Input"
             class="vtkPolyData" quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <Documentation>
The Append Geometry filter operates on multiple polygonal data sets. The data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets. It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output.
    </Documentation>
  </Module>
  <Module name="Append"
          menu_name="Append Datasets"
          root_name="Append"
          module_type="Filter"
          long_help="Takes an input of multiple datasets and output has only one unstructured grid."
          short_help="Append multiple datasets into one.">
    <Filter class="vtkAppendFilter">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <Documentation>
The Append Datasets filter operates on multiple datasets of any type (polygonal, structured, etc.). It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
    </Documentation>
  </Module>
  <Module name="CellCenters"
          menu_name="Cell Centers"
          root_name="Centers"
          module_type="Filter"
          long_help="Create a point (no geometry) at the center of each input cell."
          short_help="Convert cells to vertices.">
    <Filter class="vtkCellCenters">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Generate vertices"
                   trace_name="VertexCells"
                   variable="VertexCells"
                   help="Generate vertex as geometry of just points."
                   default_value="0"/>
    <Documentation>
The Cell Centers filter places a point at the center of each cell in the input dataset. The center computed is the parametric center of the cell, not necessarily the geometric or bounding box center. The cell attributes of the input will be associated with these newly created points of the output. The Input menu allows the user to select the data set to which this filter will be applied. If the Generate vertices option is checked, then vertex cells will also be created for each point in the output. This is useful because vertex cells are rendered, but points are not. The points themselves could be used for placing glyphs (using the Glyph filter). The Cell Centers filter takes any type of data set as input and produces a polygonal data set as output.
    </Documentation>
  </Module>
  <Module name="CellDataToPointData"
          root_name="CellToPoint"
          menu_name="Cell Data to Point Data"
          module_type="Filter"
          long_help="Create point attributes by averaging cell attributes."
          short_help="Convert cell data to point data.">
    <Filter class="vtkPCellDataToPointData">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Cell"/>
        <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Pass cell data"
                   trace_name="PassCellData"
                   variable="PassCellData"
                   help=" Control whether the input cell data is to be passed to the output. If on, then the input cell data is passed through to the output; otherwise, only generated point data is placed into the output."
                   default_value="0"/>
    <Documentation>
The Cell Data to Point Data filter averages the values of the cell attributes of the cells surrounding a point to compute point attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass cell data option is checked, then the input cell attributes will also be copied to the cell attributes of the output; otherwise the output will only have point attributes. The Cell Data to Point Data filter operates on any type of data set, and the output data set is of the same type as the input.
    </Documentation>
  </Module>
  <Module name="CleanPolyData"
          menu_name="Clean" root_name="CleanPD"
          module_type="Filter"
          long_help="Merge coincident points if they do not meet a feature edge critera."
          short_help="Merge coincident points.">
    <Filter class="vtkCleanPolyData">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Piece invariant"
                   trace_name="PieceInvariant"
                   variable="PieceInvariant"
                   help="Turn this on to remove seams when running in parallel."
                   default_value="1"/>
    <Scale variable="Tolerance"
           trace_name="Tolerance"
           help="The tolerance in terms of fraction of bounding box length."
           default_value="0.0"
           resolution="0.01" range="0 1"
           display_entry="1"
           entry_and_label_on_top="0" display_value="0"/>
  <!-- AbsoluteTolerance dependent on world-space size of data -->
  <!-- should use a widget that keeps value non-negative -->
    <VectorEntry label="Absolute tolerance"
                 variable="AbsoluteTolerance"
                 trace_name="AbsoluteTolerance" type="float"
                 help="The tolerance in absolute terms."
                 default_value="1.0"/>
    <LabeledToggle label="Tolerance is absolute"
                   trace_name="ToleranceIsAbsolute"
                   variable="ToleranceIsAbsolute"
                   help="Turn this on to use the absolute tolerance."
                   default_value="0"/>
    <LabeledToggle label="Convert lines to points"
                   trace_name="ConvertLinesToPoints"
                   variable="ConvertLinesToPoints"
                   help="Turn on/off conversion of degenerate lines to points."
                   default_value="1"/>
    <LabeledToggle label="Convert polys to lines"
                   trace_name="ConvertPolysToLines"
                   variable="ConvertPolysToLines"
                   help="Turn on/off conversion of degenerate polys to lines."
                   default_value="1"/>
    <LabeledToggle label="Convert strips to polys"
                   trace_name="ConvertStripsToPolys"
                   variable="ConvertStripsToPolys"
                   help="Turn on/off conversion of degenerate strips to polys."
                   default_value="1"/>
    <LabeledToggle label="Point merging"
                   trace_name="PointMerging"
                   variable="PointMerging"
                   help="Turn this On to control wheter points merging is performed."
                   default_value="1"/>
    <Documentation>
The Clean filter takes polygonal data as input and generates polygonal data as output. This filter can merge duplicate points, remove unused points, and transform degenerate cells into their appropriate forms (e.g., a triangle is converted into a line if two of its points are merged). The Input menu allows the user to select the data set to which this filter will be applied. If the Point merging option is on, then points will be merged if they are within the specifed Tolerance or Absolute tolerance, depending on whether the Tolerance is absolute box is checked. (Tolerance is specified as a fraction of the length of the diagonal of the bounding box of the data set; Absolute tolerance is specified in the units of the input data set.)
The transforming of degenereate cells into their appropriate forms is controlled by three check boxes on the user interface: Convert lines to points, Convert polys to lines, and Convert strips to polys. If any of these is unchecked, then degenerate cells of that type will not be converted to another type of cell.
If the Piece invariant option is checked, the whole data set will be processed at once so that cleaning this data set always produces the same results. If the box is unchecked, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory, but the results are not guaranteed to be the same as they would be if the Piece invariant option was on.
    </Documentation>
  </Module>
  <Module name="CleanUnstructuredGrid"
          menu_name="Clean to Grid"
          root_name="CleanUGrid"
          module_type="Filter"
          long_help="This filter merges points and converts the data set to unstructured grid."
          short_help="Merge points.">
    <Filter class="vtkCleanUnstructuredGrid">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Clean to Grid filter merges points that are within a tolerance of 1/100,000 of the length of the diagonal of the bounding box of the data set. It also converts the data set to an unstructured grid. The Input menu allows the user to select the data set to which this filter will be applied. The Clean to Grid filter operates on any type of data set.
    </Documentation>
  </Module>
  <Module name="PVConnectivityFilter"
          menu_name="Connectivity"
          root_name="Connect"
          module_type="Filter"
          long_help="Mark connected components with integer point attribute array."
          short_help="Find connected components.">
    <Filter class="vtkPVConnectivityFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Connectivity filter assigns a region id to connected components of the input data set. (Region id is assigned as a point scalar value.) The Input menu allows the user to select the data set to which this filter will be applied. This filter takes any data set type as input and produces unstructured grid output.
    </Documentation>
  </Module>
  <Module name="ImageClip"
          menu_name="Crop" root_name="ImageClip"
          module_type="Filter"
          replace_input="0"
          long_help="Efficiently extract an area/volume of interest from a 2-d image or 3-d volume."
          short_help="Extract a volume of interest.">
    <Filter class="vtkImageClip">
      <Input name="Input"
             class="vtkImageData"/>
    </Filter>
    <InputMenu trace_name="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ExtentEntry label="Extent to crop"
                 trace_name="OutputWholeExtent"
                 variable="OutputWholeExtent"
                 input_menu="im"
                 help="Set the min/max extents in each dimension of the output"/>
    <Documentation>
The Crop filter extracts an area/volume of interest from a 2D image or a 3D volume by allowing the user to specify the minimum and maximum extents of each dimension of the data. The Input menu allows the user to select the data set to which this filter will be applied. Both the input and output of this filter are of type image data.
    </Documentation>
  </Module>
  <Module name="Curvatures"
          menu_name="Curvature"
          root_name="Curvatures"
          module_type="Filter"
          long_help="This filter will compute the gaussian or mean curvature of the mesh at each point."
          short_help="Compute the curvature at each point.">
    <Filter class="vtkCurvatures">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Invert mean curvature"
                   trace_name="InvertMeanCurvature"
                   variable="InvertMeanCurvature"
                   help="Turn this on to invert the mean curvature calculation for meshes with inward pointing normals."
                   default_value="0"/>
    <SelectionList variable="CurvatureType"
                   label="Curvature type"
                   trace_name="CurvatureType"
                   help="Select the curvature type."
                   default_value="0">
      <Item name="Gaussian" value="0"/>
      <Item name="Mean" value="1"/>
    </SelectionList>
    <Documentation>
The Curvature filter computes the curvature at each point in a polygonal data set. This filter supports both Gaussian and mean curvatures; the type can be selected from the Curvature type menu button. The Input menu allows the user to select the data set to which this filter will be applied. If the Invert mean curvature option is checked, the mean curvature calculation will be inverted. This is useful for meshes with inward-pointing normals.
    </Documentation>
  </Module>
  <Module name="DecimatePro"
          menu_name="Decimate"
          root_name="Deci"
          module_type="Filter"
          long_help="Simplify a polygonal model using an adaptive edge collapse algorithm.  This filter works with triangles only."
          short_help="Reduce the number of triangles in a model.">
    <Filter class="vtkDecimatePro">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Reduction target"
           trace_name="TargetReduction"
           variable="TargetReduction"
           help="Value between 0 and 1. Desired reduction of the total number of triangles."
           default_value="0.90"
           resolution="0.01" range="0 1"
           display_entry="1"
           entry_and_label_on_top="0" display_value="0"/>
    <LabeledToggle label="Preserve topology"
                   trace_name="PreserveTopology"
                   variable="PreserveTopology"
                   help="If off, better reduction can occur, but model may break up."
                   default_value="0"/>
    <Scale label="Feature angle"
           trace_name="FeatureAngle"
           variable="FeatureAngle"
           help="This angle is used to define a feature edge. (i.e., if the surface normal between two adjacent triangles is >= Feature angle, an edge exists). Topology can be split along feature edges."
           default_value="15.0"
           resolution="0.01" range="0 180"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <LabeledToggle label="Boundary deletable"
                   trace_name="BoundaryVertexDeletion"
                   variable="BoundaryVertexDeletion"
                   help="If off, decimate will not remove points on the boundary."
                   default_value="1"/>
    <Documentation>
The Decimate filter reduces the number of triangles in a polygonal data set. Because this filter only operates on triangles, first run the Triangulate filter on a data set that contains polygons other than triangles. The Input menu allows the user to select the data set to which this filter will be applied. The Reduction target slider specifies the desired reduction in the total number of polygons (e.g., if the Reduction target value is 0.9, the Decimate filter will attempt to produce an output data set that is 10% the size of the input.) If the Preserve topology option is on, decimation will not split the data set or produce holes, but it may keep the filter from reaching the reduction target. The Feature angle slider value is used in determining where the data set may be split. If the angle between two adjacent triangles is &gt;= the Feature angle value, then their boundary is considered a feature edge where the data set can be split. If the Boundary deletable option is on, then vertices on the boundary of the data set can be removed. Turning this option off preserves the boundary of the data set, but it may cause the filter not to reach its reduction target.
    </Documentation>
  </Module>
  <Module name="D3"
          menu_name="D3" root_name="D3"
          module_type="Filter"
          multiprocess_support="multiple_processes"
          long_help="Repartition a data set into load-balanced spatially convex regions."
          short_help="Repartition a data set.">
    <Filter class="vtkDistributedDataFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Assign cells uniquely" 
                   trace_name="AssignBoundaryCellsToOneRegion" 
                   variable="AssignBoundaryCellsToOneRegion" 
                   help="Each cell is assigned to one process only (isosurfacing)" 
                   default_value="1"/>
    <LabeledToggle label="or Duplicate cells" 
                   trace_name="AssignBoundaryCellsToAllIntersectingRegions" 
                   variable="AssignBoundaryCellsToAllIntersectingRegions" 
                   help="Cells on processor boundaries will be duplicated" 
                   default_value="0"/>
    <LabeledToggle label="or Divide cells" 
                   trace_name="DivideBoundaryCells" 
                   variable="DivideBoundaryCells" 
                   help="Cells on processor boundaries will be split (volume rendering)" 
                   default_value="0"/>
    <StringEntry variable="GlobalIdArrayName"
                 trace_name="GlobalIdArrayName"
                 help="Provide name of global node ID array so redistributed data does not duplicate node IDs" />
    <Documentation>
    </Documentation>
  </Module>
  <Module name="ElevationFilter"
          menu_name="Elevation"
          root_name="Elevation"
          module_type="Filter"
          long_help="Create point attribute array by projecting points onto an elevation vector."
          short_help="Create a point array representing elevation.">
    <Filter class="vtkElevationFilter">
      <Input name="Input"
             class="vtkDataSet">
        <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
  <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Scalar range"
                 trace_name="ScalarRange"
                 variable="ScalarRange"
                 type="float" length="2"
                 default_value="0.0 1.0"
                 help="Set the range of scalar values to generate" />
    <LineWidget trace_name="Line"
                point1_variable="LowPoint"
                point2_variable="HighPoint"
                point1_label="Low Point"
                point2_label="High Point"
                use_label="0"
                show_resolution="0"
                help="Set the minimum and maximum point for elevation"/>
    <Documentation>
The Elevation filter generates point scalar values for an input data set along a specified direction vector. The Input menu allows the user to select the data set to which this filter will be applied. Use the Scalar range entry boxes to specify the minimum and maximum scalar value to be generated. The Low Point and High Point define a line onto which each point of the dataset is projected. The minimum scalar value is associated with the Low Point and the maximum scalar value is associated with the High Point. The scalar value for each point in the data set is determined by the location along the line to with that point projects.
The line can be specifed interactively using the 3D line widget. See section 6.4 for more information about this widget.
    </Documentation>
  </Module>
#ifdef PARAVIEW_BUILD_DEVELOPMENT
  <Module name="CTHPartAMR"
          menu_name="Extract CTH Parts"
          root_name="CTHPartAMR"
          module_type="Filter"
          long_help="Create a surface from a CTH volume fraction."
          short_help="Extract a part from a CTH dataset.">
    <Filter class="vtkCTHExtractAMRPart">
      <Input name="Input"
             class="vtkCTHData">
        <ArrayRequirement attribute="Cell" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectCTHArrays input_menu="im"
                     trace_name="ArraySelection"
                     help="Select the volume fraction arrays for generating parts."/>
    <SelectWidget variable="Clipping"
                  trace_name="Clipping" type="int">
      <Item label="On" value="1">
        <ImplicitPlaneWidget use_label="0" trace_name="Plane"
                             variable="ClipPlane" input_menu="im"
                             help="Adjusts the parameters of the plane to clip with."/>
      </Item>
      <Item label="Off" value="0">
        <DummyWidget trace_name="Dummy"/>
      </Item>
    </SelectWidget>
  </Module>
#endif
  <Module name="CTHPart"
          menu_name="Extract CTH Parts"
          root_name="CTHPart"
          module_type="Filter"
          long_help="Create a surface from a CTH volume fraction."
          short_help="Extract a part from a CTH dataset.">
    <Filter class="vtkExtractCTHPart">
      <Input name="Input"
             class="vtkRectilinearGrid">
        <ArrayRequirement attribute="Cell" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectCTHArrays input_menu="im"
                     trace_name="ArraySelection"
                     help="Select the volume fraction arrays for generating parts."/>
    <SelectWidget variable="Clipping"
                  trace_name="Clipping" type="int">
      <Item label="On" value="1">
        <ImplicitPlaneWidget use_label="0" trace_name="Plane"
                             variable="ClipPlane" input_menu="im"
                             help="Adjusts the parameters of the plane to clip with."/>
      </Item>
      <Item label="Off" value="0">
        <DummyWidget trace_name="Dummy"/>
      </Item>
    </SelectWidget>
    <Documentation>
Extract CTH Parts is a specialized filter for visualizing the data from a CTH simulation. It first converts the selected cell-centered arrays to point-centered ones. It then contours each array at a value of 0.5. The user has the option of clipping the resulting surface(s) with a plane.
If the Show All option is on, all the cell-centered scalar (single-component) arrays will be displayed in the array selection box; otherwise only the ones with "Fraction" or "fraction" in the name will be shown. (This behavior is because by default the CTH volume fraction arrays should be listed.) Clicking on the name of a particular array selects it. To choose multiple contiguous array names, click the first one and press the Shift key while clicking the last name you wish to select. If the names are not contigous, press the Ctrl key while selecting the names from the list. The selected arrays will be contoured.
If you wish to clip the contour surfaces with a plane, select "On" from the menu in the Clipping section on this Parameters tab. You can interactively position and orient the plane using the plane widget. (See the 3D Widgets section for the details of using this widget or manually setting the plane's parameters.)
This filter only operates on unstructured data. It produces polygonal output.
    </Documentation>
  </Module>
  <Module name="ExtractEdges"
          menu_name="Extract Edges"
          root_name="ExtractEdges"
          module_type="Filter"
          long_help="Extract edges of 2-d and 3-d cells as lines."
          short_help="Covert data to wireframe.">
    <Filter class="vtkExtractEdges">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Extract Edges filter produces a wireframe version of the input data set by extracting the edges of the data set's cells as lines. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data set and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="ExtractParts"
          menu_name="Extract Parts"
          root_name="ExtractParts"
          module_type="Filter"
          long_help="Extract a subset of parts from a group."
          short_help="Extract a subset of parts from a group.">
    <Filter class="vtkSelectInputs">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <ExtractPartsWidget trace_name="parts"
                        help="Choose the parts to extract."/>
    <Documentation>
The Extract Parts filter operates on any type of data, but its input reader/source/filter must have created multiple parts. The output type of this filter depends on the output type of the selected part(s). This filter is useful for operating on only a subset of the parts available from a reader, source, or filter.
    </Documentation>
  </Module>
  <Module name="DataSetSurfaceFilter"
          menu_name="Extract Surface"
          root_name="Surface"
          module_type="Filter"
          long_help="Extract a 2-d boundary surface using neighbor relations to eliminate internal faces."
          short_help="Extract 2-d boundary surface.">
    <Filter class="vtkDataSetSurfaceFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Extract Surface filter extracts the polygons forming the outer surface of the input data set. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data and produces polygonal data as output.
    </Documentation>
  </Module>
  <Module name="Calculator"
          class="vtkPVSource"
          root_name="Calc"
          button_image="PVCalculatorButton"
          button_help="Create new arrays using mathematical operations and existing arrays."
          module_type="Filter"
          long_help="Compute new attribute arrays as function of existing arrays."
          short_help="Compute new attribute arrays.">
    <Filter class="vtkArrayCalculator">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement/>
        <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <StringEntry variable="ResultArrayName"
                 trace_name="ResultArray"
                 label="Result Array Name"
                 help="Set the name of the array to hold the results of this computation"
                 default_value="Result"/>
    <CalculatorWidget trace_name="Equation"
                      help="Enter the equation for the new array."/>
    <Documentation>
The Calculator filter computes new data arrays as functions of existing scalar or vector arrays. The Input menu allows the user to select the data set to which this filter will be applied. The Result Array Name entry box allows the user to specify the name of the computed data array. The Attribute Mode menu selects whether to operate on point-centered arrays or cell-centered ones. If point-centered arrays are used, the resulting array will also be point-centered. The same is true for cell-centered arrays. The Calculator interface operates similarly to a scientific calculator. In creating the function to evaluate, the standard order of operations applies.
Each of the calculator functions is described below. Unless otherwise noted, enclose the operand in parentheses using the ( and ) buttons.
Clear: Erase the current function (displayed in the read-only text box above the calculator buttons).
/: Divide one scalar by another. The operands for this function are not required to be enclosed in parentheses.
*: Multiply two scalars or multiply a vector by a scalar (scalar multiple). The operands for this function are not required to be enclosed in parentheses.
-: Negate a scalar or vector (unary minus) or subtract one scalar or vector from another. The operands for this function are not required to be enclosed in parentheses.
+: Add two scalars or two vectors. The operands for this function are not required to be enclosed in parentheses.
sin: Compute the sine of a scalar.
cos: Compute the cosine of a scalar.
tan: Compute the tangent of a scalar.
asin: Compute the arcsine of a scalar.
acos: Compute the arccosine of a scalar.
atan: Compute the arctangent of a scalar.
sinh: Compute the hyperbolic sine of a scalar.
cosh: Compute the hyperbolic cosine of a scalar.
tanh: Compute the hyperbolic tangent of a scalar.
x^y: Raise one scalar to the power of another scalar. The operands for this function are not required to be enclosed in parentheses.
sqrt: Compute the square root of a scalar.
e^x: Raise e to the power of a scalar.
log: Compute the logarithm of a scalar.
ceil: Compute the ceiling of a scalar.
floor: Compute the floor of a scalar.
abs: Compute the absolute value of a scalar.
v1.v2: Compute the dot product of two vectors. The operands for this function are not required to be enclosed in parentheses.
mag: Compute the magnitude of a vector.
norm: Normalize a vector.
The operands is described below.
The digits, 0 - 9, and the decimal point are used to enter constant scalar values.
iHat, jHat, and kHat are vector constants representing unit vectors in the X, Y, and Z directions, respectively.
The scalars menu lists the names of the scalar arrays and the components of the vector arrays of either the point-centered or cell-centered data. The vectors menu lists the names of the point-centered or cell-centered vector arrays. The function will be computed for each point (or cell) using the scalar or vector value of the array at that point (or cell).
The filter operates on any type of data set, but the input data set must have at least one scalar or vector array. The arrays can be either point-centered or cell-centered. The Calculator filter's output is of the same data set type as the input.
The Calculator filter is available on the Toolbar.
    </Documentation>
  </Module>
  <Module name="FeatureEdges"
          menu_name="Feature Edges"
          root_name="FeatureEdges"
          module_type="Filter"
          replace_input="0"
          long_help="This filter will extract edges along sharp edges of surfaces or boundaries of surfaces."
          short_help="Extract edges that meet the feature critera.">
    <Filter class="vtkFeatureEdges">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Boundary edges"
                   trace_name="BoundaryEdges"
                   variable="BoundaryEdges"
                   help="Turn this off if you do not want to extract boundary edges."
                   default_value="1"/>
    <LabeledToggle label="Feature edges"
                   trace_name="FeatureEdges"
                   variable="FeatureEdges"
                   help="Turn this off if you do not want to extract feature edges."
                   default_value="1"/>
    <LabeledToggle label="Non-manifold edges"
                   trace_name="NonManifoldEdges"
                   variable="NonManifoldEdges"
                   help="Turn this off if you do not want to extract non-manifold edges."
                   default_value="1"/>
    <LabeledToggle label="Manifold edges"
                   trace_name="ManifoldEdges"
                   variable="ManifoldEdges"
                   help="Turn this on if you want to extract manifold edges."
                   default_value="0"/>
    <LabeledToggle variable="Coloring"
                   trace_name="Coloring"
                   help="Turn this off if you do not want to color the edges by type."
                   default_value="1"/>
    <Scale label="Feature angle"
           trace_name="FeatureAngle"
           variable="FeatureAngle"
           help="This angle is used to define a feature edge. (i.e., if the surface normal between two adjacent triangles is >= Feature angle, an edge exists).."
           default_value="30.0"
           resolution="0.01"
           range="0 180"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Feature Edges filter extracts various types of edges from the input data set. The Input menu allows the user to select the data set to which this filter will be applied. Which edges are extracted depends on which check boxes are marked. The four types of edges are as follows.
Boundary edges: line cells or edges used by only one polygon
Feature edges: edges used by two polygons whose dihedral angle &gt; the value from the Feature angle slider
Non-manifold edges: edges used by three or more polygons
Manifold edges: edges used by exactly two polygons
If the Coloring option is checked, then the extracted edges are assigned a scalar value based on the type of the edge.
This filter operates on polygonal data and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="Gradient"
          menu_name="Gradient" root_name="Grad"
          module_type="Filter">
    <Filter class="vtkPVImageGradient">
      <Input name="Input"
             class="vtkImageData">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu input_name="Input"
               attribute_type="Scalars" label="Scalars"
               trace_name="ArrayMenu"
               input_menu="im" number_of_components="1"
               help="Select the input scalars to process."/>
    <SelectionList variable="Dimensionality"
                   trace_name="Dimensionality"
                   default_value="3"
                   help="Select whether to perform a 2d or 3d gradient">
      <Item name="2"
            value="2"/>
      <Item name="3"
            value="3"/>
    </SelectionList>
    <Documentation>
The Gradient filter computes the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu determines which from which scalar array the gradient will be computed. The Dimensionality menu selects whether the gradient will be calculated in 2 or 3 dimensions. If only 2 dimensions are used, gradients are only computed in X and Y. This filter uses central differences to compute the gradients. The Gradient filter operates on image data and produces image data output.
    </Documentation>
  </Module>
  <Module name="GradientMagnitude"
          menu_name="Gradient Magnitude"
          root_name="GradM"
          module_type="Filter">
    <Filter class="vtkPVImageGradientMagnitude">
      <Input name="Input"
             class="vtkImageData">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu input_name="Input"
               attribute_type="Scalars" label="Scalars"
               trace_name="ArrayMenu"
               input_menu="im"
               help="Select the input scalars to process."/>
    <SelectionList variable="Dimensionality"
                   trace_name="Dimensionality"
                   default_value="3"
                   help="Select whether to perform a 2d or 3d gradient magnitude">
      <Item name="2"
            value="2"/>
      <Item name="3"
            value="3"/>
    </SelectionList>
    <Documentation>
The Gradient Magnitude filter computes the magnitude of the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu allows the user to select which scalar array will be used for gradient magnitude calculations. The Dimensionality menu determines whether the gradient magnitude will be computed in 2 or 3 dimensions. If 2 dimensions are used, the gradient magnitude will be computed from the gradients in X and Y. This filter operates on image data and produces image data output.
    </Documentation>
  </Module>
  <Module name="GroupParts"
          menu_name="Group Parts"
          root_name="GroupParts"
          module_type="Filter"
          replace_input="1"
          long_help="Group parts."
          short_help="Group multiple inputs into one collection.">
    <Filter class="vtkGroup">
      <Input name="Input"
             class="vtkDataSet" quantity="Multiple"/>
    </Filter>
    <GroupInputsWidget trace_name="inputs"
                       help="Choose inputs to group."/>
    <Documentation>
The Group Parts filter causes different data sets to be grouped into a collection and treated as a single data set for filtering purposes. To select a single data set, click on its name. To select several sources whose names are contiguous in the list, select the first name, press and hold the Shift key, and (while still holding the Shift key) click the last name. To select several data sets whose names are non-contiguous, press and hold the Ctrl key while clicking the names. This filter operates on any type of data. The output type depends on the data sets selected for grouping.
    </Documentation>
  </Module>
  <Module name="LinearExtrusionFilter"
          menu_name="Linear Extrusion"
          root_name="LinExtrude"
          module_type="Filter"
          long_help="This filter creates a swept surface defined by translating the input along a vector."
          short_help="Generate a linear swept surface.">
    <Filter class="vtkPVLinearExtrusionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- ScaleFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Scale factor"
                 trace_name="ScaleFactor"
                 variable="ScaleFactor" type="float"
                 help="Set the extrusion scale factor"
                 default_value="1.0"/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry variable="Vector"
                 trace_name="Vector"
                 type="float" length="3"
                 help="Set the direction for the extrusion"
                 default_value="0.0 0.0 1.0"/>
    <LabeledToggle variable="Capping"
                   trace_name="Capping"
                   help="Select whether to draw endcaps" 
                   default_value="1"/>
    <LabeledToggle label="Piece invariant"
                   trace_name="PieceInvariant"
                   variable="PieceInvariant"
                   help="Turn this off if you do want to process ghost levels and do not mind seams."
                   default_value="0"/>
    <Documentation>
The Linear Extrusion filter creates a swept surface by translating the input data set along a specified vector. This filter was intended to operate on 2D polygonal data. The Input menu allows the user to select the data set to which this filter will be applied. The three Vector entry boxes specify the X, Y, and Z components of the vector along which to sweep the input. The value of the Scale factor determines the distance along the vector the data set will be translated. (A scale factor of 0.5 will move the data set half the length of the vector, and a scale factor of 2 will move it twice the vector's length.) The Capping check box indicates whether to cap the ends of the swept surface. If the input data set is 3D instead of 2D (e.g., a sphere), then if capping is on, two copies of the data set will be displayed on output (the second translated from the first one along the specified vector). If instead capping is off, then an input 3D data set will produce no output. The Piece invariant check box determines whether the output will be the same regardless of the number of processors used to compute the result. The difference is whether there are internal polygonal faces on the processor boundaries. This filter operates on polygonal data and produces polygonal data output.
    </Documentation>
  </Module>
  <Module name="LoopSubdivisionFilter"
          menu_name="Loop Subdivision"
          root_name="LoopSubDiv"
          module_type="Filter"
          long_help="This filter iteratively divides each triangle into four triangles.  New points are placed so the output surface is smooth."
          short_help="Create a higher resolution and smoother surface.">
    <Filter class="vtkLoopSubdivisionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Number of divisions"
           trace_name="NumberOfSubdivisions"
           variable="NumberOfSubdivisions"
           help="Each subdivision changes single triangles into four triangles."
           default_value="1"
           resolution="1" range="1 4"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Loop Subdivision filter increases the granularity of a polygonal mesh. It works by dividing each triangle in the input into four new triangles. This filter only operates on triangles, so a data set that contains other types of polygons should be passed through the Triangulate filter before applying this filter to it. The Input menu allows the user to select the data set to which this filter will be applied. The Number of divisions slider specifies the number of subdivision iterations to be performed. (For example, if the number of divisions is 2, the triangles in the initial mesh will each be divided into four new triangles. Then those new triangles will be further subdivided.) This filter only operates on polygonal data (specifically triangle meshes), and it produces polygonal output.
    </Documentation>
  </Module>
  <Module name="MaskPoints"
          menu_name="Mask Points"
          root_name="MaskPts"
          module_type="Filter"
          long_help="Reduce the number of points.  This filter is often used before glyphing.  Generating vertices is an option."
          short_help="Reduce the number of points.">
   <Filter class="vtkMaskPoints">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- should use widget that keeps value positive -->
    <VectorEntry label="On ratio"
                 trace_name="OnRatio"
                 variable="OnRatio"
                 help="The ratio of points retained."
                 type="int"
                 default_value="2"/>
    <!-- should use widget that keeps value non-negative -->
    <VectorEntry label="Max. points"
                 trace_name="MaximumNumberOfPoints"
                 variable="MaximumNumberOfPoints"
                 help="Limit the number of points."
                 type="int"
                 default_value="5000"/>
    <!-- should use widget that keeps value non-negative -->
    <VectorEntry variable="Offset"
                 trace_name="Offset"
                 help="Start with this point."
                 type="int"
                 default_value="0"/>
    <LabeledToggle label="Random" trace_name="Random"
                   variable="RandomMode"
                   help="Select whether to randomly select points, or subsample regularly."
                   default_value="0"/>
    <LabeledToggle label="Generate vertices"
                   trace_name="GenerateVertices"
                   variable="GenerateVertices"
                   help="Convienience feature to display points."
                   default_value="0"/>
    <Documentation>
The Mask Points filter reduces the number of points in the data set. It operates on any type of data set, but produces only points / vertices. This filter is often used before the Glyph filter, but now the basic point-masking functionality is available on the Parameters page for the Glyph filter.
The Input menu allows the user to select the data set to which this filter will be applied. The value in the On ratio entry box specifies the ratio of points to retain in the output. (For example, if the on ratio is 3, then the output will contain 1/3 as many points -- up to the Max. points value -- as the input.) The Max. points entry box determines the maximum number of points that will appear in the output. The Offset entry box specifies the point in the data set from which to start masking. If the Random check box is marked, then the output points will be selected randomly from the input; otherwise every nth point (specified by the on ratio) will be selected. Selecting points at random is helpful to avoid striping when masking the points of a structured data set. If the Generate vertices option is checked, then a vertex cell will be created for each point in the output.
    </Documentation>
  </Module>
  <Module name="Median"
          root_name="Median" module_type="Filter">
    <Filter class="vtkPVImageMedian3D">
      <Input name="Input"
             class="vtkImageData">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu input_name="Input"
               attribute_type="Scalars"
               label="Scalars"
               trace_name="Scalars"
               input_menu="im"
               number_of_components="1"
               help="Select the input scalars to process."/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Kernel Size"
                 trace_name="KernelSize"
                 variable="KernelSize" type="int"
                 length="3"
                 help="Determines the smoothing neighborhood."
                 default_value="1 1 1"/>
    <Documentation>
The Median filter operates on image data and produces image data output. It replaces the scalar value at each pixel / voxel with the median scalar value in the specified surrounding neighborhood (Kernes Size). From the Input menu, the user can select the data set for performing this calculation. The Scalar menu determines which scalar array will be used to determine the median. The Kernel Size entry boxes specify the number of pixels / voxels in each dimension to use in computing the median to assign to each pixel / voxel. If the kernel size in a particular dimension is 1, then the median will not be computed in that direction.
    </Documentation>
  </Module>
  <Module name="PolyDataNormals"
          menu_name="Normals generation"
          root_name="PDNormals"
          module_type="Filter"
          long_help="This filter will produce surface normals used for smooth shading.  Spltting is used to avoid smoothing across feature edges."
          short_help="Produce surface point normals.">
    <Filter class="vtkPPolyDataNormals">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Feature angle"
           trace_name="FeatureAngle"
           variable="FeatureAngle"
           help="Points are duplicated along features over this angle (0->180)"
           default_value="30.0"
           resolution="0.01" range="0 180"
           display_entry="1"
           entry_and_label_on_top="0" display_value="0"/>
    <LabeledToggle variable="Splitting"
                   trace_name="Splitting"
                   help="Turn on/off the splitting of sharp edges."
                   default_value="1"/>
    <LabeledToggle variable="Consistency"
                   trace_name="Consistency"
                   help="Turn on/off the enforcement of consistent polygon ordering."
                   default_value="1"/>
    <LabeledToggle label="Flip normals"
                   trace_name="FlipNormals"
                   variable="FlipNormals"
                   help="Flipping reverves the meaning of front and back."
                   default_value="0"/>
    <LabeledToggle label="Non-manifold"
                   trace_name="NonManifoldTraversal"
                   variable="NonManifoldTraversal"
                   help="Turn on/off traversal across non-manifold edges. This will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops."
                   default_value="1"/>
    <LabeledToggle label="Cell normals"
                   trace_name="ComputeCellNormals"
                   variable="ComputeCellNormals"
                   help="Turn on/off the computation of cell normals."
                   default_value="0"/>
    <LabeledToggle label="Piece invariant"
                   trace_name="PieceInvariant"
                   variable="PieceInvariant"
                   help="Turn this off if you do not want to process ghost levels and do not mind seams."
                   default_value="1"/>
    <Documentation>
The Normals generation filter generates surface normals at the points of the input polygonal data set to provide smooth shading of the data set. The resulting data set is also polygonal. The filter works by calculating a normal vector for each polygon in the data set and then averaging the normals at the shared points.
In creating surface normals, if the angle between two polygons at a shared edge is larger than the value of the Feature angle slider, then that edge is considered a feature edge. If Splitting is turned on, then the mesh will be split along feature edges, allowing points to be duplicated. Because the duplicated points are no longer shared between the polygons meeting at the feature edge, a normal at these points will be created per polygon rather than averaging the polygon normals to produce one normal at each point. This allows the feature edges to remain "sharp" after shading.
Generally the normals for a data set should either all point inward or all point outward. If the Consistency check is on, then this filter will reorder the points of cells that whose normal vectors are oriented the opposite direction from the rest of those in the data set. If the Flip normals option is checked, this filter will reverse the normal direction (and reorder the points) for all polygons in the data set. You might want to do this if your viewing position will be inside the data set instead of outside of it. Sometimes you may have more than two polygons sharing an edge (i.e., a non-manifold edge). When this is the case and the Consistency option is checked, then if the Non-manifold check is on, this filter will try to maintain consistent normals across non-manifold edge, but doing this can corrupt the ordering of polygons at these edges.
This filter computes the normals at the points in the data set. In the process of doing this it computes polygon normals too. If you want these normals to be passed to the output of this filter, turn on the Cell normals option.
If this filter is run in parallel, the resulting data set will have seams along the processor boundaries unless the Piece invariant check box is marked.
    </Documentation>
  </Module>
#ifdef PARAVIEW_BUILD_DEVELOPMENT
  <Module name="CTHOutlineFilter"
          menu_name="Outline (CTH AMR)"
          root_name="CTHOutline"
          module_type="Filter">
    <Filter class="vtkCTHOutlineFilter">
      <Input name="Input"
             class="vtkCTHData"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
  </Module>
  <Module name="StructuredGridOutlineFilter"
          menu_name="Outline (curvilinear)"
          root_name="GOutline"
            module_type="Filter">
    <Filter class="vtkStructuredGridOutlineFilter">
      <Input name="Input"
             class="vtkStructuredGrid"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
  </Module>
#endif
  <Module name="OutlineFilter"
          menu_name="Outline"
          root_name="Outline"
          module_type="Filter"
          replace_input="0"
          long_help="This filter generates a bounding box representation of the input."
          short_help="Generates a bounding box.">
    <Filter class="vtkPOutlineFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input" label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on any type of data set and produces polygonal output.
    </Documentation>
  </Module>
  <Module name="OutlineCornerFilter"
          menu_name="Outline Corners"
          root_name="COutline"
          module_type="Filter"
          replace_input="0"
          long_help="This filter generates a bounding box representation of the input.  It only displays the corners of the bounding box."
          short_help="Generates corners of a bounding box.">
    <Filter class="vtkPOutlineCornerFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Corner factor"
           trace_name="CornerFactor"
           variable="CornerFactor"
           help="The relative size of the corners to the length of the corresponding bounds. (0.001 -> 0.5)"
           default_value="0.2"
           resolution="0.001"
           range="0.001 0.5"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
The Outline Corners filter generates the corners of a bounding box for the input data set (specified by the Input men). The Corner factor slider specifies the relative length of the corners along the corresponding edges. This filter produces polygonal output.
    </Documentation>
  </Module>
  <Module name="PartScalars"
          menu_name="Part Id Scalars"
          root_name="ColorParts"
          module_type="Filter"
          long_help="This filter uses colors to show how data is partitioned across parts."
          short_help="Generate point scalars from part id.">
    <Filter class="vtkColorByPart">
      <Input name="Input"
             class="vtkDataSet"
             quantity="Multiple">
        <GroupRequirement quantity="Multiple"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
The Part Id Scalars filter assigns a unique scalar value to each part in the input. The input parts must have been collected together either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
    </Documentation>
  </Module>
  <Module name="PieceScalars"
          menu_name="Process Id Scalars"
          root_name="ColorPieces"
          module_type="Filter"
          multiprocess_support="multiple_processes"
          long_help="This filter uses colors to show how data is partitioned across processes."
          short_help="Generate point scalars from process id.">
    <Filter class="vtkPieceScalars">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Random"
                   trace_name="RandomMode"
                   variable="RandomMode"
                   help="Select whether to use random colors for the various pieces"
                   default_value="0"/>
    <Documentation>
The Process Id Scalars filter assigns a unique scalar value to each piece of the input according to which processor it resides on.
    </Documentation>
  </Module>
    <!--
  <Module name="Pick"
          root_name="Pick"
          button_help="Pick cell or point closest to the widget"
          module_type="Filter">
    <Filter class="vtkPickDataSetFilter">
      <Input name="Input"
             class="vtkDataSet" />
    </Filter>
    <LabeledToggle label="Search cells"
                   trace_name="SearchCells"
                   variable="SearchCells"
                   help="Set when cells are supposed to be searched. Otherwise points will be searched."/>
    <PointWidget variable="SamplePoint"
                 help="Sample point that we are picking."/>
  </Module>
    -->
  <Module name="PointDataToCellData"
          root_name="PointToCell"
          menu_name="Point Data to Cell Data"
          module_type="Filter"
          long_help="Create cell attributes by averaging point attributes."
          short_help="Convert point data to cell data.">
    <Filter class="vtkPointDataToCellData">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Point"/>
      <FixedTypeRequirement/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <LabeledToggle label="Pass point data"
                   trace_name="PassPointData"
                   variable="PassPointData"
                   help="If on, then the input point data is passed through to the output; otherwise, only generated cell data is placed into the output."
                   default_value="0"/>
    <Documentation>
The Point Data to Cell Data filter averages the values of the point attributes of the points of a cell to compute cell attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass point data option is checked, then the input point attributes will also be copied to the point attributes of the output; otherwise the output will only have dell attributes. The Point Data to Cell Data filter operates on any type of data set, and the output data set is of the same type as the input.
    </Documentation>
  </Module>
  <Module name="QuadricClustering"
          menu_name="Quadric Clustering"
          root_name="QC"
          module_type="Filter"
          long_help="This filter is the same filter used to generate level of detail for ParaView.  It uses a structured grid of bins and merges all points contained in each bin."
          short_help="Simplify polygonal models.">
    <Filter class="vtkQuadricClustering">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Divisions"
                 trace_name="NumberOfDivisions"
                 variable="NumberOfDivisions"
                 type="int"
                 length="3"
                 help="Set the number of bins in each dimension"
                 default_value="50 50 50"/>
    <LabeledToggle label="Use input points"
                   trace_name="UseInputPoints"
                   variable="UseInputPoints"
                   help="Select whether to use points from the input in the output or to calculate optimum representative points for each bin"
                   default_value="0"/>
    <LabeledToggle label="Use feature edges"
                   trace_name="UseFeatureEdges"
                   variable="UseFeatureEdges"
                   help="Select whether to use feature edge quadrics to match up the boundaries between pieces"
                   default_value="0"/>
    <LabeledToggle label="Use feature points"
                   trace_name="UseFeaturePoints"
                   variable="UseFeaturePoints"
                   help="Select whether to use feature point quadrics to align piece boundaries"
                   default_value="0"/>
    <LabeledToggle label="Copy cell data"
                   trace_name="CopyCellData"
                   variable="CopyCellData"
                   help="Should cell data be copied from output to input?"
                   default_value="0"/>
    <Documentation>
The Quadric Clustering filter produces a reduced-resolution polygonal approximation of the input polygonal data set. This filter is the one used by ParaView for computing LODs. It uses spatial binning to reduce the number of points in the data set; points that lie within the same spatial bin are collapsed into one representative point. The Divisions entries specify the number of bins along the X, Y, and Z axes of the data set. If Use input points is on, the representative point for each bin is selected from one of the input points that lies in that bin; the input point that produces the least error is chosen. Without this option selected, the location of the representative point is calculated to produce the least error possible for that bin, but the point will most likely not be one of the input points.
To better align pieces of the data set assigned to different processors, select Use feature edges and Use feature points. Use feature edges adjusts the representative points that contain boundary edges (along processor divisions), and Use feature points further influences the position of the feature points along the boundaries.
The Copy cell data toggle controls whether cell-centered data from the input should be copied to the output.
    </Documentation>
  </Module>
  <Module name="BrownianPoints"
          menu_name="Random Vectors"
          root_name="BPts"
          module_type="Filter"
          long_help="This filter creates a new 3 component point data array and sets it as the default vectors.  It uses a random number generator to create values."
          short_help="Create a new random vector array.">
    <Filter class="vtkBrownianPoints">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- should use a widget that keeps the value non-negative -->
    <VectorEntry label="Min. speed"
                 trace_name="MinimumSpeed"
                 variable="MinimumSpeed"
                 help="The minimum size of the random point vectors generated."
                 type="float"
                 default_value="0.0"/>
    <!-- should use a widget that keeps the value non-negative -->
    <VectorEntry label="Max. speed"
                 trace_name="MaximumSpeed"
                 variable="MaximumSpeed"
                 help="The maximum size of the random point vectors generated."
                 type="float"
                 default_value="1.0"/>
    <Documentation>
The Random Vectors filter generates a point-centered array of random vectors. It uses a random number generator to determine the components of the vectors. The Min. speed and Max. speed values determine the range of the vector magnitudes. This filter operates on any type of data set, and the output data set will be of the same type as the input.
    </Documentation>
  </Module>
  <Module name="ReflectionFilter"
          menu_name="Reflection"
          root_name="Reflect"
          module_type="Filter"
          long_help="This filter takes the union of the input and its reflection over an axis-aligned plane."
          short_help="Reflect input over an axis aligned plane.">
    <Filter class="vtkReflectionFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectionList variable="Plane"
                   trace_name="Plane"
                   help="Select which plane of the bounding box to reflect across"
                   default_value="0">
      <Item name="X"
            value="6"/>
      <Item name="Y"
            value="7"/>
      <Item name="Z"
            value="8"/>
      <Item name="X Min"
            value="0"/>
      <Item name="Y Min"
            value="1"/>
      <Item name="Z Min"
            value="2"/>
      <Item name="X Max"
            value="3"/>
      <Item name="Y Max"
            value="4"/>
      <Item name="Z Max"
            value="5"/>
    </SelectionList>
    <!-- reasonable value dependent on bounds of the data -->
    <VectorEntry label="Center"
                 trace_name="Center"
                 variable="Center"
                 type="float"
                 help="The center of the mirror plane."
                 default_value="0.0"/>
    <Documentation>
The Reflection filter reflects the input data set across the specified plane. The output is the union of the input data set and its reflection. If the value chosen from the Plane menu is X, Y, or Z, the value of the Center entry determines where the plane is placed along the specified axis. The other six entries, X Min, X Max, etc., place the reflection plane at the specified face of the bounding box of the input data set. This filter operates on any type of data set producing an unstructured grid output.
    </Documentation>
  </Module>
  <Module name="RibbonFilter"
          menu_name="Ribbon"
          root_name="Ribbon"
          module_type="Filter"
          long_help="This filter generates ribbon surface from lines.  It is useful for displaying streamlines."
          short_help="Create ribbon surfaces from lines.">
    <Filter class="vtkPVRibbonFilter">
      <Input name="Input"
             class="vtkPolyData">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu input_name="Input"
               trace_name="Vectors"
               attribute_type="Vectors"
               label="Vectors"
               input_menu="im"
               number_of_components="3"
               help="Select the input normals to process."/>
    <ArrayMenu input_name="Input"
               trace_name="Scalars"
               attribute_type="Scalars"
               label="Scalars"
               input_menu="im"
               number_of_components="1"
               help="Select the input scalars to process."/>
    <ScaleFactorEntry variable="Width"
                      input_menu="im"
                      trace_name="Width"
                      type="float"
                      scale_factor="0.01"
                      help="The half width of the ribbon (or minimum)."/>
    <Scale variable="Angle"
           trace_name="Angle"
           help="The offset angle of the ribbon from the line normal (0->360)."
           default_value="0.0"
           resolution="0.01"
           range="0 360"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <LabeledToggle label="Use default normal"
                   trace_name="UseDefaultNormal"
                   variable="UseDefaultNormal"
                   help="When this option is off, default normals will be generated if the input contains no normals. If on, the Default normal will be used."
                   default_value="0"/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Default normal"
                 trace_name="DefaultNormal"
                 variable="DefaultNormal"
                 type="float"
                 length="3"
                 help="Specify the normal to use if Use default normal is on."
                 default_value="0.0 0.0 1.0"/>
    <LabeledToggle label="Vary width"
                   trace_name="VaryWidth"
                   variable="VaryWidth"
                   help="Turn on/off the variation of ribbon width with scalar value."
                   default_value="0"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="RotationalExtrusionFilter"
          menu_name="Rotational Extrusion"
          root_name="RotExtrude"
          module_type="Filter"
          long_help="This filter generates a swept surface while translates the input along a circular path."
          short_help="Generates a swept surface using a rotational path.">
    <Filter class="vtkRotationalExtrusionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- should use widget that keeps value positive -->
    <VectorEntry variable="Resolution"
                 trace_name="Resolution"
                 type="int"
                 default_value="12"/>
    <LabeledToggle variable="Capping"
                   trace_name="Capping" default_value="1"/>
    <VectorEntry variable="Angle"
                 trace_name="Angle"
                 help="Set the angle of rotation."
                 type="float"
                 default_value="360.0"/>
    <!-- Translation value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry variable="Translation"
                 trace_name="Translation"
                 type="float"
                 help="The total amount of translation along the z-axis."
                 default_value="0.0"/>
    <!-- DeltaRadius value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Delta radius"
                 trace_name="DeltaRadius"
                 variable="DeltaRadius"
                 type="float"
                 help="The change in radius during sweep process."
                 default_value="0.0"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="ShrinkFilter"
          menu_name="Shrink"
          root_name="Shrink"
          module_type="Filter"
          long_help="This filter shrinks each input cell so they pull away from their neighbors."
          short_help="Shrink each input cell.">
    <Filter class="vtkShrinkFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Shrink factor"
           trace_name="ShrinkFactor"
           variable="ShrinkFactor"
           help="Set the amount to shrink by"
           default_value="0.5"
           resolution="0.01"
           range="0 1"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
    </Documentation>
  </Module>
    <!--
  <Module name="ShrinkPolyData"
          menu_name="Shrink (polygons)"
          root_name="ShrinkPD" module_type="Filter"
          long_help="This filter shrinks each input cell so they pull away from their neighbors.  The output is always of type unstructured grid."
          short_help="Shrink each input cell.">
    <Filter class="vtkShrinkPolyData">
      <Input name="Input"
             class="vtkPolyData" />
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <VectorEntry label="Shrink factor"
                 trace_name="ShrinkFactor"
                 variable="ShrinkFactor"
                 type="float"
                 help="Set the amount to shrink by"
                 default_value="0.5"/>
  </Module>
    -->
  <Module name="SmoothPolyDataFilter"
          menu_name="Smooth"
          root_name="Smooth"
          module_type="Filter"
          long_help="This filter smooths a polygonal surface by iteratively moving points toward their neighbors."
          short_help="Smooth a polygonal surface without adding more points.">
    <Filter class="vtkSmoothPolyDataFilter">
      <Input name="Input"
           class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- should use widget that keeps value non-negative -->
    <VectorEntry label="Num. iterations"
                 trace_name="NumberOfIterations"
                 variable="NumberOfIterations"
                 help="Number of iterations. More iterations produces better smoothing."
                 type="int"
                 default_value="20"/>
    <Scale variable="Convergence"
           trace_name="Convergence"
           help="Convergence criterion for the iteration process. Smaller numbers result in more smoothing iterations (0->1)."
           default_value="0.0"
           resolution="0.01"
           range="0 1"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Stripper"
          menu_name="Triangle Strips"
          root_name="Strip"
          module_type="Filter"
          long_help="This filter uses a greedy algorythm to convert triangles into triangle strips"
          short_help="Convert triangles into triangle strips.">
    <Filter class="vtkStripper">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Scale label="Max. length"
           trace_name="MaximumLength"
           variable="MaximumLength"
           help="Stop stripping after this many triangles."
           default_value="1000"
           resolution="1"
           range="4 100000"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Subdivide"
          root_name="Subdivide"
          module_type="Filter"
          button_help="Subdivide the poly data into more polygons"
          long_help="This filter iteratively divide triangles into four smaller triangles.  New points are placed linearly so the output surface matches the input surface."
          short_help="Creates a surface with more triangles than the input.">
    <Scale label="Num. divisions"
           trace_name="NumberOfSubdivisions"
           variable="NumberOfSubdivisions"
           help="Set the number of subdivisions"
           default_value="1"
           resolution="1"
           range="1 4"
           display_entry="1"
           entry_and_label_on_top="0"
           display_value="0"/>
    <Filter class="vtkLinearSubdivisionFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="DataSetTriangleFilter"
          menu_name="Tetrahedralize"
          root_name="Tetra"
          module_type="Filter"
          long_help="This filter converts 3-d cells to tetrahedrons and polygons to triangles.  The output is always of type unstructured grid."
          short_help="Convert to tetrahedrons and triangles.">
    <Filter class="vtkDataSetTriangleFilter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="TriangleFilter"
          menu_name="Triangulate"
          root_name="Tri"
          module_type="Filter"
          long_help="This filter converts polygons and traingle strips to basic triangles."
          short_help="Convert polygonal data to triangles.">
    <Filter class="vtkTriangleFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="TransformFilter"
          menu_name="Transform"
          root_name="Trans"
          module_type="Filter"
          long_help="This filter applies transformation to the polygons."
          short_help="Transform polygonal data.">
    <Filter class="vtkTransformFilter">
      <Input name="Input"
             class="vtkPointSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <SelectWidget label="Transform Widget"
                  trace_name="Transform Widget"
                  variable="Transform"
                  type="object">
      <Item label="Box"
            value="BoxTransform">
      <BoxWidget use_label="0"
                 trace_name="Box"
                 help="Adjusts the parameters of the box to clip with."/>
      </Item>
    </SelectWidget>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="TubeFilter"
          menu_name="Tube"
          root_name="Tuber"
          module_type="Filter"
          long_help="Convert lines into tubes.  Normals are used to avoid cracks between tube segments."
          short_help="Convert lines into tubes.">
    <Filter class="vtkTubeFilter">
      <Input name="Input"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <!-- should use widget that keeps value > 2 -->
    <VectorEntry label="Num. sides"
                 variable="NumberOfSides"
                 trace_name="NumberOfSides"
                 help="Set the number of sides for the tube"
                 type="int"
                 default_value="6"/>
    <LabeledToggle variable="Capping"
                   trace_name="Capping"
                   help="Select whether to draw endcaps on the tube"
                   default_value="0"/>
    <ScaleFactorEntry variable="Radius"
                      input_menu="im"
                      trace_name="Radius"
                      type="float"
                      scale_factor="0.01"
                      help="Set the radius of the tube" />
    <SelectionList label="Vary radius"
                   trace_name="VaryRadius"
                   variable="VaryRadius"
                   help="Select whether/how to vary the radius of the tube"
                   default_value="0">
      <Item name="Off"
            value="0"/>
      <Item name="ByScalar"
            value="1"/>
      <Item name="ByVector"
            value="2"/>
    </SelectionList>
    <!-- RadiusFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Radius factor"
                 trace_name="RadiusFactor"
                 variable="RadiusFactor"
                 type="float"
                 help="Set the maximum tube radius in terms of a multiple of the minimum radius"
                 default_value="10"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="WarpScalar"
          menu_name="Warp (scalar)"
          root_name="WarpS"
          default="scalars"
          module_type="Filter"
          long_help="This filter moves point coordinates along a vector scaled by a point attribute.  It can be used to produce carpet plots."
          short_help="Warp point scalars into a spatial elevation plot.">
    <Filter class="vtkPVWarpScalar">
      <Input name="Input"
             class="vtkPointSet">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu input_name="Input"
               attribute_type="Scalars"
               trace_name="Scalars"
               label="Scalars"
               input_menu="im"
               help="Select the input scalars to process."/>
    <!-- ScaleFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Scale factor"
                 variable="ScaleFactor"
                 trace_name="ScaleFactor"
                 type="float"
                 help="Displacement is vector times scale."
                 default_value="1.0"/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry variable="Normal"
                 trace_name="Normal"
                 type="float"
                 length="3"
                 help="Warp direction."
                 default_value="0.0 0.0 1.0"/>
    <LabeledToggle label="Use normal"
                   trace_name="UseNormal"
                   variable="UseNormal"
                   help="Use instance model normals rather than instance normal."
                   default_value="0"/>
    <LabeledToggle label="X-Y plane"
                   trace_name="XYPlane"
                   variable="XYPlane"
                   help="Z value is used to warp the surface, scalars to color surface."
                   default_value="0"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="WarpVector"
          root_name="WarpV"
          menu_name="Warp (vector)"
          button_image="PVVectorDisplacementButton"
          button_help="Warp (displace) the geometry with a given vector field."
          default="vectors"
          module_type="Filter"
          long_help="This filter displaces point coordinates along a vector attribute.  It is useful for showing mechanical deformation."
          short_help="Warp (displace) the geometry with a given vector field.">
    <Filter class="vtkPVWarpVector">
      <Input name="Input"
             class="vtkPointSet">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu input_name="Input"
               attribute_type="Vectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               number_of_components="3"
               help="Select the input vectors to process."/>
    <!-- ScaleFactor value chosen does not change processing speed of this filter or cause it to crash. -->
    <VectorEntry label="Scale factor"
                 trace_name="ScaleFactor"
                 variable="ScaleFactor"
                 type="float"
                 help="Displacement is vector times scale."
                 default_value="1.0"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Cut"
          root_name="Cut"
          replace_input="0"
          module_type="Filter"
          button_image="PVCutButton"
          button_help="Cut with an implicit plane or sphere. Cutting typically reduces the dimensionality of the data."
          long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
          short_help="Cut datasets with planes or spheres.">
#ifdef VTK_USE_PATENTED
    <Filter class="vtkKitwareCutter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
#else
    <Filter class="vtkCutter">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
#endif
    <InputMenu trace_name="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <BoundsDisplay show_hide_frame="1"
                   label="Input Bounds"
                   trace_name="Input Bounds"
                   input_menu="im1"/>
    <SelectWidget type="object"
                  label="Cut Function"
                  trace_name="Cut Function"
                  variable="CutFunction">
      <Item label="Plane"
            value="Plane">
      <ImplicitPlaneWidget trace_name="Plane"
                           use_label="0"
                           input_menu="im1"
                           help="Adjusts the parameters of the plane to cut with."/>
      </Item>
      <Item label="Sphere"
            value="Sphere">
      <SphereWidget trace_name="Sphere"
                    use_label="0"
                    help="Adjusts the parameters of the sphere to cut with."/>
      </Item>
    </SelectWidget>
    <CutEntry label="Cut Offset Values"
              trace_name="Cut Values"
              initial_value="0"
              input_menu="im1"
              help="List of current offset values. This can be used to create multiple cut planes/spheres with different centers. Each entry represents a new cut with center shifted by the offset value."
              set_number_command="SetNumberOfContours"
              set_contour_command="SetValue"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Clip"
          root_name="Clip"
          module_type="Filter"
          button_image="PVClipButton"
          button_help="Clip with an implicit plane, sphere or with scalars.Clipping does not reduce the dimensionality of the data set."
          long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
          short_help="Clip with an implicit plane, sphere or with scalars.">
    <Filter class="vtkPVClipDataSet">
      <Input name="Input"
             class="vtkDataSet"/>
    </Filter>
    <InputMenu trace_name="Input"
               id="im1"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <BoundsDisplay show_hide_frame="1"
                   label="Input Bounds"
                   trace_name="Input Bounds"
                   input_menu="im1"/>
    <SelectWidget type="object"
                  label="Clip Function"
                  trace_name="Clip Function"
                  variable="ClipFunction">
      <Item label="Plane"
            value="Plane">
        <ImplicitPlaneWidget use_label="0"
                             trace_name="Plane"
                             input_menu="im1"
                             help="Adjusts the parameters of the plane to clip with."/>
      </Item>
      <Item label="Sphere"
            value="Sphere">
        <SphereWidget use_label="0"
                      trace_name="Sphere"
                      help="Adjusts the parameters of the sphere to clip with."/>
      </Item>
      <Item label="Box"
            value="Box">
        <BoxWidget use_label="0"
                   trace_name="Box"
                   help="Adjusts the parameters of the box to clip with."/>
      </Item>
      <Item label="Scalars">
        <ContainerWidget trace_name="ScalarClip">
          <Item>
            <ScalarRangeLabel trace_name="ScalarRange" array_menu="it3.am1"/>
          </Item>
          <Item id="it3">
          <ArrayMenu id="am1"
                     input_name="Input"
                     attribute_type="Scalars"
                     trace_name="Scalars"
                     label="Scalars"
                     help="Choose the clipping scalar array."
                     input_menu="im1"/>
          </Item>
          <Item>
            <!-- Value depends on scalar range of input -->
            <VectorEntry label="Clip value"
                         trace_name="Offset"
                         type="float"
                         variable="Value"
                         help="Choose the scalar value to clip with"/>
          </Item>
        </ContainerWidget>
      </Item>
    </SelectWidget>
    <LabeledToggle label="Inside Out"
                   trace_name="InsideOut"
                   variable="InsideOut"
                   help="Switches which part to keep."
                   default_value="0"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Threshold"
          root_name="Threshold"
          button_image="PVThresholdButton"
          module_type="Filter"
          button_help="Extract cells that satisfy a threshold criterion."
          long_help="This filter extracts cells that have point scalars in the specified range."
          short_help="Extract cells that satisfy a threshold criterion.">
    <Filter class="vtkPVThresholdFilter">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement components="1"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               input_name="Input"
               help="Set the input to this filter." />
    <FieldMenu id="fm"
               trace_name="FieldMenu"
               input_menu="im"
               help="Choose cell or point field to threshold." />
    <ArrayMenu id="am"
               input_name="Input"
               attribute_type="Scalars"
               trace_name="Scalars"
               label="Scalars"
               field_menu="fm"
               help="Choose the threshold scalar array."/>
    <MinMax trace_name="MinMax"
            array_menu="am"
            min_label="Lower Threshold"
            max_label="Upper Threshold"
            min_help="Choose the lower value of the threshold"
            max_help="Choose the upper value of the threshold"
            get_min_command="GetLowerThreshold"
            get_max_command="GetUpperThreshold"
            set_command="ThresholdBetween"/>
    <LabeledToggle label="All Scalars"
                   trace_name="AllScalars"
                   variable="AllScalars"
                   default_value="1"
                   help="If AllScalars is checked, then a cell is only included if all its points are within the threshold. This is only relevant for point data."/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Contour"
          root_name="Contour"
          button_image="PVContourButton"
          module_type="Filter"
          replace_input="0"
          button_help="Generate isolines or isosurfaces."
          long_help="Generate isolines or isosurfaces using point scalars."
          short_help="Generate isolines or isosurfaces.">
#ifdef VTK_USE_PATENTED
    <Filter class="vtkPVKitwareContourFilter">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
#else
    <Filter class="vtkPVContourFilter">
      <Input name="Input"
             class="vtkDataSet">
        <ArrayRequirement attribute="Point" components="1"/>
      </Input>
    </Filter>
#endif
    // Do not change the tracename of the input menu, it is used by vtkPVContour
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               input_name="Input"
               help="Set the input to this filter." />
    // Do not change the tracename of the array menu, it is used by vtkPVContour
    <ArrayMenu id="am"
               input_name="Input"
               attribute_type="Scalars"
               label="Scalars"
               trace_name="Scalars"
               input_menu="im"
               number_of_components="1"
               help="Choose which scalar array you want to contour."/>
    <ScalarRangeLabel id="srl"
                      trace_name="ScalarRangeLabel"
                      array_menu="am"/>
    <ContourEntry label="Contour Values"
                  trace_name="Contour Values"
                  array_menu="am"
                  set_number_command="SetNumberOfContours"
                  set_contour_command="SetValue"
                  help="List of current contour values." />
    <LabeledToggle label="Compute Normals"
                   variable="ComputeNormals"
                   default_value="1"
                   trace_name="Compute Normals"
                   help="Select whether to compute normals" />
    <LabeledToggle label="Compute Gradients"
                   variable="ComputeGradients"
                   default_value="0"
                   trace_name="Compute Gradients"
                   help="Select whether to compute gradients"/>
    <LabeledToggle label="Compute Scalars"
                   variable="ComputeScalars"
                   default_value="0"
                   trace_name="Compute Scalars"
                   help="Select whether to compute scalars" />
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Glyph"
          root_name="Glyph"
          module_type="Filter"
          button_image="PVGlyphButton"
          replace_input="0"
          button_help="Generate a glyph (symbol) at each point of the dataset. These can be colored, scaled and oriented"
          long_help="This filters generates an arrow, sphere, or cone at each point of the input data set.  The glyphs can be oriented and scale by the input point attributes."
          short_help="Generate a glyph symbol at each point of the input data set.">
    <Filter class="vtkPVGlyphFilter">
      <Input name="Input"
             class="vtkDataSet"/>
      <Input name="Source"
             class="vtkPolyData"/>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <InputMenu trace_name="Glyph"
               id="im2"
               label="Glyph"
               help="Select the glyph source."
               input_name="Source"
               source_list="GlyphSources"/>
    <OrientScaleWidget trace_name="OrientScale" input_menu="im"
                       scalars_command="SelectInputScalars"
                       vectors_command="SelectInputVectors"
                       orient_command="SetOrient"
                       scale_mode_command="SetScaleMode"
                       scale_factor_command="SetScaleFactor"
                       default_orient_mode="1"
    default_scale_mode ="1"/>
    <!-- should use a widget to keep value non-negative -->
    <VectorEntry label="Max. Number of Glyphs"
                 trace_name="Max Glyphs"
                 variable="MaximumNumberOfPoints"
                 type="int"
                 default_value="5000"
                 help="Set the maximum number of points to glyph" />
    <LabeledToggle label="Mask Points"
                   trace_name="MaskPoints"
                   variable="UseMaskPoints"
                   default_value="1"
                   help="Create no more than specified maximum number of glyphs" />
    <LabeledToggle label="Random Masking"
                   trace_name="RandomMask"
                   variable="RandomMode"
                   default_value="1"
                   help="Choose points at random to mask" />
    <Documentation>
    </Documentation>
  </Module>
  <Module name="Probe"
          class="vtkPVProbe"
          root_name="Probe"
          button_image="PVProbeButton"
          button_help="Sample data values at a point or along a line"
          module_type="Filter"
          long_help="Sample data attributes at a point or along a line.  Probed lines will be displayed in a graph of the attributes."
          short_help="Sample data values at a point or along a line.">
    <Filter class="vtkPProbeFilter">
      <Input name="Source"
             class="vtkDataSet">
        <GroupRequirement quantity="Single"/>
        <ArrayRequirement attribute="Point"/>
      </Input>
    </Filter>
    <SelectWidget type="object"
                  label="Probe object"
                  trace_name="Probe object"
                  variable="Input">
      <Item label="Point"
            value="Output">
      <PointSourceWidget trace_name="Point"
                         default_radius="0"
                         default_number_of_points="1"
                         show_entries="0"/>
      </Item>
        <Item label="Line"
              value="Output">
        <LineSourceWidget trace_name="Line"/>
      </Item>
    </SelectWidget>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="StreamTracer"
          root_name="Stream"
          menu_name="Stream Tracer"
          module_type="Filter"
          replace_input="0"
          button_image="PVStreamTracerButton"
          button_help="Generate streamtraces from a collection of seed points."
          long_help="Integrate streamlines in a vector field."
          short_help="Integrate streamlines in a vector field.">
    <Filter class="vtkDistributedStreamTracer">
      <Input name="Input"
             class="vtkDataSet"
             quantity="Multiple">
        <ArrayRequirement attribute="Point" components="3"/>
      </Input>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ArrayMenu input_name="Input"
               attribute_type="Vectors"
               trace_name="Vectors"
               label="Vectors"
               input_menu="im"
               number_of_components="3"
               help="Select the input vectors to use."/>
    <SelectWidget type="object"
                  trace_name="Seed"
                  label="Seed"
                  variable="Source">
      <Item label="Point Cloud"
            value="Output">
        <PointSourceWidget trace_name="Point"
                           radius_scale_factor=".1"
                           input_menu="im"
                           default_number_of_points="100"
                           show_entries="1"/>
      </Item>
      <Item label="Line"
            value="Output">
        <LineSourceWidget trace_name="Line"/>
      </Item>
    </SelectWidget>
    <ContainerWidget pack_direction="left" trace_name="MaxProp">
      <Item>
        <SelectionList variable="MaximumPropagationUnit"
                       trace_name="MaximumPropagationUnit"
                       label="Max. Propagation"
                       option_width="15"
                       help="Maximum propagation"
                       default_value="1">
          <Item name="Time"
                value="0"/>
          <Item name="Length"
                value="1"/>
        </SelectionList>
      </Item>
      <Item>
        <ScaleFactorEntry label=""
                          variable="MaximumPropagation"
                          type="float"
                          trace_name="MaxPropLen"
                          scale_factor="1.0"
                          input_menu="im"
                          help="Maximum propagation" />
      </Item>
    </ContainerWidget>
    <ContainerWidget pack_direction="left" trace_name="InitLen">
      <Item>
        <SelectionList trace_name="InitialIntegrationStepUnit"
                       variable="InitialIntegrationStepUnit"
                       label="Init. Step Len."
                       option_width="15"
                       help="Initial step length"
                       default_value="2">
          <Item name="Time"
                value="0"/>
          <Item name="Length"
                value="1"/>
          <Item name="Cell Length"
                value="2"/>
        </SelectionList>
      </Item>
      <Item>
        <VectorEntry label=""
                     variable="InitialIntegrationStep"
                     type="float"
                     trace_name="InitLen"
                     help="Initial step length"
                     default_value="0.5"/>
      </Item>
    </ContainerWidget>
    <SelectionList trace_name="IntegrationDirection"
                   variable="IntegrationDirection" 
                   option_width="15"
                   default_value="2">
      <Item name="FORWARD"
            value="0"/>
      <Item name="BACKWARD"
            value="1"/>
      <Item name="BOTH"
            value="2"/>
    </SelectionList>
    <SelectWidget type="int"
                  variable="IntegratorType"
                  trace_name="IntegrationType">
      <Item label="Runge-Kutta 2" value="0">
        <DummyWidget trace_name="Dummy1"/>
      </Item>
      <Item label="Runge-Kutta 4" value="1">
        <DummyWidget trace_name="Dummy2"/>
      </Item>
      <Item label="Runge-Kutta 4-5" value="2">
        <ContainerWidget trace_name="MinLen">
      <Item>
        <ContainerWidget pack_direction="left" trace_name="MinLen">
          <Item>
            <SelectionList variable="MinimumIntegrationStepUnit"
                           trace_name="MinimumIntegrationStepUnit"
                           label="Min. Step Len."
                           option_width="15"
                           help="Minimum step length used in the integation"
                           default_value="2">
              <Item name="Time"
                    value="0"/>
              <Item name="Length"
                    value="1"/>
              <Item name="Cell Length"
                    value="2"/>
            </SelectionList>
          </Item>
          <Item>
            <VectorEntry label=""
                         variable="MinimumIntegrationStep"
                         type="float"
                         trace_name="MinLen"
                         help="Minimum step length  used in the integation"
                         default_value="0.01"/>
          </Item>
        </ContainerWidget>
      </Item>
      <Item>
        <ContainerWidget pack_direction="left" trace_name="MaxLen">
          <Item>
            <SelectionList variable="MaximumIntegrationStepUnit"
                           trace_name="MaximumIntegrationStepUnit"
                           label="Max. Step Len."
                           option_width="15"
                           help="Maximum step length used in the integration"
                           default_value="2">
              <Item name="Time"
                    value="0"/>
              <Item name="Length"
                    value="1"/>
              <Item name="Cell Length"
                    value="2"/>
            </SelectionList>
          </Item>
          <Item>
            <VectorEntry label=""
                         variable="MaximumIntegrationStep"
                         type="float"
                         trace_name="MaxLen"
                         help="Maximum step length used in the integration"
                         default_value="1.0"/>
          </Item>
        </ContainerWidget>
      </Item>
      <Item>
      <VectorEntry label="Maximum Error"
                   trace_name="MaximumError"
                   variable="MaximumError"
                   type="float"
                   help="Maximum error allowed in the integration"
                   default_value="0.000001"/>
      </Item>
      </ContainerWidget>
      </Item>
    </SelectWidget>
    <VectorEntry label="Max. Steps"
                 trace_name="MaximumNumberOfSteps"
                 variable="MaximumNumberOfSteps"
                 type="int"
                 help="Maximum number of steps."
                 default_value="2000"/>
    <VectorEntry label="Term. Speed"
                 trace_name="TerminalSpeed"
                 variable="TerminalSpeed"
                 type="float"
                 help="Terminal speed. The integration will be stopped if the speed (absolute value) is smaller than this threshold"
                 default_value="0.000000000001"/>
    <Documentation>
    </Documentation>
  </Module>
  <Module name="ExtractGrid"
          root_name="ExtractGrid"
          menu_name="Extract Grid"
          module_type="Filter"
          button_image="PVExtractGridButton"
          replace_input="0"
          button_help="Extract a subgrid or subsample."
          long_help="Extract a subgrid from a structured grid with the option of setting subsample strides."
          short_help="Extract a subgrid or subsample.">
    <Filter class="vtkPVExtractVOI">
      <Input name="Input"
             class="vtkStructuredData"/>
    </Filter>
    <InputMenu trace_name="Input"
               id="im"
               label="Input"
               help="Set the input to this filter."
               input_name="Input"/>
    <ExtentEntry variable="VOI"
                 trace_name="VOI"
                 input_menu="im"
                 help="Set the min/max values of the volume of interest (VOI). The output will have the (I,J,K) extent specified here."/>
    <!-- keeping vector entries with length > 1 -->
    <VectorEntry label="Sample rate"
                 trace_name="SampleRate"
                 variable="SampleRate"
                 type="int" length="3"
                 default_value="1 1 1"
                 help="Set the sampling rate for each dimension" />
    <LabeledToggle label="Include boundary"
                   variable="IncludeBoundary"
                   trace_name="IncludeBoundary"
                   default_value="0"
                   help="Select whether to always include the boundary of the grid in the output"/>
    <Documentation>
    </Documentation>
  </Module>
</ModuleInterfaces>
